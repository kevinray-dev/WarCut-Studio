<!DOCTYPE html>
<html lang="en" data-app="warcut-studio">
<head>
<meta charset="UTF-8" />
<title>Warcut Studio ¬∑ Mockup</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --bg:#05070a;
    --bg2:#101627;
    --panel:#0b1222;
    --panel2:#0f172a;
    --border:#1f2937;
    --border2:#223044;

    /* Warchief cyan/blue */
    --accent:#38bdf8;
    --accent2:#60a5fa;
    --accentSoft:rgba(56,189,248,.14);

    --text:#e5edf7;
    --muted:#9caac7;
    --soft:#6c7a99;

    --ok:#22c55e;
    --warn:#f6ad55;
    --danger:#f56565;

    --r8:8px;
    --r12:12px;
    --r16:16px;
    --r20:20px;

    --shadow:0 22px 60px rgba(0,0,0,.70);
    --shadow2:0 12px 34px rgba(0,0,0,.55);

    --font:system-ui,-apple-system,BlinkMacSystemFont,"SF Pro Text","Segoe UI",sans-serif;

    /* timeline scale */
    --pxPerSec: 84; /* user adjustable */
    --trackH: 56px;
  }

  *{box-sizing:border-box;}
  html,body{height:100%;margin:0;background:radial-gradient(circle at top,var(--bg2) 0,var(--bg) 55%);color:var(--text);font-family:var(--font);overflow:hidden;}
  a{color:inherit}
  button,input,select{font-family:inherit}
  ::-webkit-scrollbar{height:10px;width:10px}
  ::-webkit-scrollbar-thumb{background:rgba(148,163,184,.22);border-radius:999px;border:2px solid rgba(2,6,23,.7)}
  ::-webkit-scrollbar-track{background:rgba(2,6,23,.35)}

  /* Root */
  .app{height:100vh;max-height:100vh;display:flex;flex-direction:column;min-height:0;overflow:hidden;}

  /* Menubar */
  .menubar{
    height:34px;flex:0 0 auto;
    display:flex;align-items:center;gap:10px;padding:0 10px;
    border-bottom:1px solid var(--border);
    font-size:12px;color:var(--muted);
    background:rgba(2,6,23,.90);backdrop-filter: blur(8px);
    user-select:none;
  }
  .menu-item{padding:6px 8px;border-radius:10px;border:1px solid transparent;cursor:default}
  .menu-item:hover{border-color:rgba(56,189,248,.35);background:rgba(56,189,248,.06);color:var(--text)}
  .brand{margin-left:auto;display:flex;align-items:center;gap:10px;min-width:0}
  .badge{
    font-size:11px;letter-spacing:.14em;text-transform:uppercase;padding:3px 10px;border-radius:999px;
    border:1px solid rgba(56,189,248,.65);
    background:radial-gradient(circle at 0 0, rgba(56,189,248,.18), transparent 60%);
    color:#7dd3fc;
    white-space:nowrap;
  }
  .ver{font-size:11px;padding:3px 8px;border-radius:999px;border:1px solid rgba(148,163,184,.35);color:var(--muted);background:rgba(15,23,42,.7);white-space:nowrap;}

  /* Toolbar */
  .toolbar{
    height:44px;flex:0 0 auto;
    display:flex;align-items:center;justify-content:space-between;gap:10px;
    padding:0 10px;border-bottom:1px solid var(--border);
    background:rgba(2,6,23,.86);backdrop-filter: blur(8px);
    min-width:0;
  }
  .toolcluster{display:flex;align-items:center;gap:8px;flex-wrap:wrap;min-width:0;}
  .btn,.chip,select,input[type="text"],input[type="number"],input[type="range"]{
    background:rgba(15,23,42,.72);color:var(--text);border:1px solid rgba(148,163,184,.22);
    border-radius:999px;padding:7px 10px;font-size:12px;outline:none;
  }
  select{padding-right:26px;max-width:240px}
  .btn{cursor:pointer;}
  .btn:hover{border-color:rgba(56,189,248,.55); box-shadow:0 0 0 1px rgba(56,189,248,.10);}
  .btn:active{transform:translateY(1px);}
  .btn.primary{border-color:rgba(56,189,248,.85);background:radial-gradient(circle at 0 0, rgba(56,189,248,.18), rgba(15,23,42,.75));}
  .btn.danger{border-color:rgba(245,101,101,.55);background:radial-gradient(circle at 0 0, rgba(245,101,101,.14), rgba(15,23,42,.75));}
  .btn.ghost{border-color:rgba(148,163,184,.18);background:rgba(15,23,42,.45);color:var(--muted);}
  .sep{width:1px;height:22px;background:rgba(148,163,184,.18);margin:0 6px;}
  .chip{color:var(--muted);}
  .dot{display:inline-block;width:8px;height:8px;border-radius:999px;background:rgba(148,163,184,.55);margin-right:6px;vertical-align:middle}
  .dot.ok{background:rgba(34,197,94,.9)}
  .dot.warn{background:rgba(246,173,85,.95)}

  /* Main workspace grid */
  .workspace{flex:1;min-height:0;display:grid;grid-template-columns: 280px minmax(0,1fr) 340px;gap:12px;padding:12px;overflow:hidden;}
  .panel{
    border-radius:18px;border:1px solid rgba(148,163,184,.16);
    background:linear-gradient(180deg, rgba(2,6,23,.78), rgba(2,6,23,.62));
    box-shadow:var(--shadow2);
    display:flex;flex-direction:column;min-height:0;overflow:hidden;
  }
  .panel-header{
    padding:10px 12px;border-bottom:1px solid rgba(148,163,184,.12);
    display:flex;align-items:center;justify-content:space-between;gap:10px;min-width:0;
    background:rgba(2,6,23,.55);
  }
  .panel-header .title{font-size:12px;letter-spacing:.12em;text-transform:uppercase;color:var(--muted);white-space:nowrap;}
  .panel-header .meta{font-size:11px;color:var(--soft);white-space:nowrap;}
  .panel-body{flex:1;min-height:0;overflow:auto;padding:10px 12px;}
  .small{font-size:11px;color:rgba(156,163,175,.92);line-height:1.35}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}

  /* Media bin */
  .bin-actions{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px;}
  .bin-list{display:flex;flex-direction:column;gap:8px;}
  .media-item{
    border:1px solid rgba(148,163,184,.14);
    background:rgba(15,23,42,.55);
    border-radius:14px;
    padding:10px;
    cursor:pointer;
    display:grid;
    grid-template-columns: 46px 1fr;
    gap:10px;
    min-width:0;
  }
  .media-item:hover{border-color:rgba(56,189,248,.45)}
  .media-item.active{
    border-color:rgba(56,189,248,.9);
    box-shadow:0 0 0 1px rgba(56,189,248,.14), 0 12px 26px rgba(0,0,0,.35);
  }
  .thumb{
    width:46px;height:46px;border-radius:12px;border:1px solid rgba(148,163,184,.12);
    background:rgba(2,6,23,.55);
    display:flex;align-items:center;justify-content:center;
    color:rgba(229,231,235,.85);
    overflow:hidden;
  }
  .thumb video,.thumb img{width:100%;height:100%;object-fit:cover;display:block}
  .m-title{font-size:12px;color:var(--text);font-weight:650;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .m-meta{margin-top:4px;font-size:11px;color:var(--muted);display:flex;gap:8px;flex-wrap:wrap}
  .pillmini{padding:2px 8px;border-radius:999px;border:1px solid rgba(148,163,184,.16);background:rgba(2,6,23,.40);white-space:nowrap;}

  /* Preview area (center) */
  .center{display:flex;flex-direction:column;min-width:0;min-height:0;gap:12px;overflow:hidden;}
  .stage{
    flex:1;min-height:0;
    border-radius:18px;border:1px solid rgba(148,163,184,.16);
    background:linear-gradient(180deg, rgba(11,18,36,.70), rgba(2,6,23,.82));
    box-shadow:var(--shadow);
    display:flex;flex-direction:column;overflow:hidden;
  }
  .pillmini.ok{border-color:rgba(34,197,94,.55);background:rgba(34,197,94,.10);}
  .pillmini.warn{border-color:rgba(245,158,11,.55);background:rgba(245,158,11,.10);}
  .stage-top{
    height:42px;flex:0 0 auto;
    display:flex;align-items:center;justify-content:space-between;gap:10px;padding:0 12px;
    border-bottom:1px solid rgba(148,163,184,.12);
    color:var(--muted);font-size:12px;user-select:none;
    min-width:0;
  }
  .stage-top .left, .stage-top .right{display:flex;align-items:center;gap:8px;flex-wrap:wrap;min-width:0;}
  .zoomchip{
    border-radius:999px;padding:5px 10px;border:1px solid rgba(148,163,184,.22);
    background:rgba(15,23,42,.60);color:var(--muted);
    white-space:nowrap;
  }
  .viewport{
    flex:1;min-height:0;
    display:flex;align-items:center;justify-content:center;
    padding:12px;overflow:auto;
  }
  .preview-shell{
    width:min(1120px, 100%); /* doesn't overflow */
    aspect-ratio: 16 / 9;
    border-radius:16px;
    border:1px solid rgba(148,163,184,.18);
    background:
      linear-gradient(45deg, rgba(255,255,255,.06) 25%, transparent 25%) 0 0/18px 18px,
      linear-gradient(45deg, transparent 75%, rgba(255,255,255,.06) 75%) 0 0/18px 18px,
      linear-gradient(45deg, transparent 25%, rgba(255,255,255,.06) 25%) 9px 9px/18px 18px,
      linear-gradient(45deg, rgba(255,255,255,.06) 75%, transparent 75%) 9px 9px/18px 18px,
      rgba(15,23,42,.52);
    position:relative;
    overflow:hidden;
    display:flex;
    align-items:stretch;
    justify-content:stretch;
  
    /* Phase 2.4: viewport zoom/pan (Ctrl+drag to zoom, Space+drag to pan). */
    transform: translate(var(--vpPanX, 0px), var(--vpPanY, 0px)) scale(var(--vpScale, 1));
    transform-origin: center center;
    will-change: transform;
  }
  video#previewVideo{
    width:100%;
    height:100%;
    object-fit:contain;
    background:#000;
    display:block;
  }
  .overlay-layer{
    position:absolute;inset:0;pointer-events:none;
  }
.bg-layer{
    position:absolute;inset:0;pointer-events:none;
  }
  .bg-layer.interactive{ pointer-events:auto; }
  /* Phase A ‚Äî Stage 5.1 (hotfix): allow dragging overlays in preview when interactive */
  .overlay-layer.interactive{ pointer-events:auto; }
  .overlay-layer.interactive .lowerthird{
    touch-action:none; pointer-events:auto; cursor:grab; user-select:none; }
  .overlay-layer.interactive .lowerthird.dragging{ cursor:grabbing; }
  .overlay-layer.interactive .lowerthird.selected{
    outline:2px solid rgba(56,189,248,.55);
    outline-offset:2px;
  }
  .safe-guide{
    position:absolute;inset:0;display:none;pointer-events:none;
  }
  .safe-guide::before,.safe-guide::after{
    content:"";position:absolute;inset:8%;border:1px dashed rgba(56,189,248,.35);border-radius:14px;
  }
  .safe-guide::after{
    inset:14%;
    border-color:rgba(246,173,85,.30);
  }

  /* Lower third sample */
  .lowerthird{
    position:absolute;
    left:4.5%;
    bottom:7%;
    max-width:72%;
    padding:10px 12px;
    border-radius:14px;
    border:1px solid rgba(56,189,248,.35);
    background:linear-gradient(135deg, rgba(2,6,23,.84), rgba(2,6,23,.52));
    box-shadow:0 12px 32px rgba(0,0,0,.55);
    backdrop-filter: blur(8px);
  }

  /* Image overlay (PNG / stills) */
  .imgov{
    touch-action:none;
    position:absolute;
    left:4.5%;
    bottom:7%;
    max-width:35%;
    max-height:35%;
    height:auto;
    width:auto;
    border-radius:12px;
    box-shadow:0 12px 32px rgba(0,0,0,.55);
    pointer-events:auto;
    cursor:grab;
    user-select:none;
  }
  .overlay-layer.interactive .imgov.dragging{ cursor:grabbing; }
  .overlay-layer.interactive .imgov.selected{
    outline:2px solid rgba(56,189,248,.55);
    outline-offset:2px;
  }

  /* Overlay resize handle (Phase 4A hotfix) */
  .ov-handle{
    position:absolute;
    right:-10px;
    bottom:-10px;
    width:18px;height:18px;
    border-radius:8px;
    background:rgba(56,189,248,.18);
    border:1px solid rgba(56,189,248,.55);
    box-shadow:0 6px 18px rgba(0,0,0,.45);
    cursor:nwse-resize;
    pointer-events:auto;
    touch-action:none;
  }
  .ov-handle::after{
    content:"";
    position:absolute;inset:5px;
    border-right:2px solid rgba(56,189,248,.65);
    border-bottom:2px solid rgba(56,189,248,.65);
    border-radius:1px;
  }
  .imgov-img{
    display:block;
    width:auto;
    height:auto;
    max-width:100%;
    max-height:100%;
    object-fit:contain;
    border-radius:12px;
  }


  .lt-kicker{
    font-size:10px;letter-spacing:.18em;text-transform:uppercase;color:rgba(125,211,252,.92);
    margin-bottom:4px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis
  }
  .lt-title{font-size:18px;font-weight:800;letter-spacing:.01em;color:rgba(229,231,235,.98);line-height:1.05;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .lt-sub{margin-top:4px;font-size:12px;color:rgba(156,163,175,.92);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

  .stage-bottom{
    height:34px;flex:0 0 auto;
    border-top:1px solid rgba(148,163,184,.12);
    display:flex;align-items:center;justify-content:space-between;gap:10px;padding:0 12px;
    font-size:12px;color:var(--muted);
    min-width:0;
  }
  .kbd{
    font-size:11px;border:1px solid rgba(148,163,184,.22);
    background:rgba(15,23,42,.65);padding:2px 8px;border-radius:8px;color:var(--text);
    white-space:nowrap;
  }

  /* Inspector (right) */
  .tabs{display:flex;gap:8px;padding:10px 12px;border-bottom:1px solid rgba(148,163,184,.12);background:rgba(2,6,23,.35);}
  .tab{
    flex:1;text-align:center;padding:8px 10px;border-radius:999px;border:1px solid rgba(148,163,184,.18);
    background:rgba(15,23,42,.45);color:var(--muted);font-size:12px;cursor:pointer;user-select:none;
  }
  .tab.active{
    border-color:rgba(56,189,248,.75);
    background:radial-gradient(circle at 0 0, rgba(56,189,248,.18), rgba(15,23,42,.55));
    color:var(--text);
  }
  .pane{display:none;}
  .pane.active{display:block;}
  .block{
    border:1px solid rgba(148,163,184,.16);
    background:rgba(15,23,42,.55);
    border-radius:16px;
    padding:10px;
    margin-bottom:10px;
    overflow:hidden;
  }
  .block h3{margin:0 0 8px;font-size:11px;letter-spacing:.12em;text-transform:uppercase;color:var(--muted);}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px;min-width:0;}
  .field label{display:block;font-size:11px;color:var(--muted);margin:0 0 6px;}
  .field input,.field select,.field textarea{
    width:100%;
    border-radius:12px;
    padding:8px 10px;
    border:1px solid rgba(148,163,184,.18);
    background:rgba(2,6,23,.55);
    color:var(--text);
    outline:none;
    min-width:0;
  }
  .field textarea{resize:none;height:72px}
  .field input:focus,.field select:focus,.field textarea:focus{border-color:rgba(56,189,248,.75);box-shadow:0 0 0 2px rgba(56,189,248,.10);}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;min-width:0;}
  .hint{
    font-size:11px;color:rgba(156,163,175,.92);
    padding:8px 10px;border-radius:14px;border:1px solid rgba(148,163,184,.14);
    background:rgba(2,6,23,.35);
    line-height:1.35;
  }
  .hint.warn{
    border-color:rgba(246,173,85,.35);
    background:rgba(246,173,85,.08);
    color:rgba(246,173,85,.95);
  }

  /* Timeline (bottom of center column) */
  .timeline{
    height:240px;flex:0 0 auto;
    border-radius:18px;border:1px solid rgba(148,163,184,.16);
    background:linear-gradient(180deg, rgba(2,6,23,.92), rgba(2,6,23,.82));
    box-shadow:var(--shadow2);
    overflow:hidden;
    display:flex;flex-direction:column;min-height:160px;
  }
  .timeline-resize{
    height:8px;cursor:ns-resize;
    background:linear-gradient(180deg, rgba(56,189,248,.24), transparent);
    border-bottom:1px solid rgba(148,163,184,.10);
  }
  .timeline-top{
    height:44px;flex:0 0 auto;
    border-bottom:1px solid rgba(148,163,184,.12);
    display:flex;align-items:center;justify-content:space-between;gap:10px;padding:0 12px;
    color:var(--muted);font-size:12px;min-width:0;
  }
  .transport{display:flex;align-items:center;gap:8px;flex-wrap:wrap;min-width:0;}
  .tbtn{
    width:34px;height:34px;border-radius:12px;border:1px solid rgba(148,163,184,.18);background:rgba(15,23,42,.55);
    display:flex;align-items:center;justify-content:center;cursor:pointer;color:var(--text);user-select:none;
  }
  .tbtn:hover{border-color:rgba(56,189,248,.55);}
  .tbtn.primary{
    border-color:rgba(56,189,248,.85);
    background:radial-gradient(circle at 0 0, rgba(56,189,248,.22), rgba(15,23,42,.60));
  }
  .timeline-main{flex:1;min-height:0;display:grid;grid-template-columns: 190px minmax(0,1fr);}
  .tracklist{
    border-right:1px solid rgba(148,163,184,.12);
    padding:10px;overflow:auto;
  }
  .track{
    border:1px solid rgba(148,163,184,.14);
    background:rgba(15,23,42,.50);
    border-radius:14px;
    padding:10px;margin-bottom:8px;
  }
  .track .name{font-size:12px;color:var(--text);font-weight:650}
  .track .meta{margin-top:6px;font-size:11px;color:var(--muted);display:flex;gap:8px;flex-wrap:wrap;}
  .frames{
    min-width:0;display:flex;flex-direction:column;overflow:hidden;position:relative;
  }
  .ruler{
    height:28px;flex:0 0 auto;
    border-bottom:1px solid rgba(148,163,184,.12);
    position:relative;
    overflow:hidden;
    padding:0 10px;
    box-sizing:border-box;
    color:rgba(156,163,175,.9);font-size:11px;user-select:none;
  }
  .ruler-inner{
    position:relative;
    height:28px;
    min-width: max(100%, calc(var(--timelineLen, 20) * var(--pxPerSec) * 1px));
    will-change:transform;
  }
  .rtick{
    position:absolute;bottom:0;width:1px;height:8px;
    background:rgba(148,163,184,.18);
  }
  .rtick.major{
    height:14px;
    background:rgba(148,163,184,.32);
  }
  .rlabel{
    position:absolute;top:5px;
    transform:translateX(-50%);
    white-space:nowrap;
  }
  .tick{height:10px;width:1px;background:rgba(148,163,184,.18);}
  .lane-scroll{
    flex:1;min-height:0;
    overflow:auto;
    position:relative;
    padding:10px;
  }
  .lanes{
    position:relative;
    min-width: max(100%, calc(var(--timelineLen, 20) * var(--pxPerSec) * 1px));
  }
  .lane{
    height:var(--trackH);
    border-radius:16px;
    border:1px dashed rgba(148,163,184,.14);
    margin-bottom:10px;
    position:relative;
    background:rgba(2,6,23,.28);
    overflow:hidden;
  }
  .lane:last-child{margin-bottom:0}
  .clip{
    touch-action:none;
    position:absolute;top:8px;bottom:8px;
    border-radius:14px;
    border:1px solid rgba(148,163,184,.18);
    background:linear-gradient(135deg, rgba(56,189,248,.16), rgba(15,23,42,.75));
    color:rgba(229,231,235,.95);
    padding:8px 10px;
    display:flex;flex-direction:column;gap:4px;
    cursor:pointer;
    user-select:none;
    overflow:hidden;
  }
  .clip.audio{
    background:linear-gradient(135deg, rgba(34,197,94,.14), rgba(15,23,42,.75));
    border-color:rgba(34,197,94,.35);
  }
  .clip.gfx{
    background:linear-gradient(135deg, rgba(246,173,85,.14), rgba(15,23,42,.75));
    border-color:rgba(246,173,85,.35);
  }
  .clip.active{
    border-color:rgba(56,189,248,.95);
    box-shadow:0 0 0 1px rgba(56,189,248,.16), 0 14px 30px rgba(0,0,0,.35);
  }

  .clip.disabled{
    opacity:.42;
    filter:saturate(.65);
  }
  .clip.solo{
    box-shadow:0 0 0 2px rgba(56,189,248,.55) inset, 0 14px 30px rgba(0,0,0,.35);
  }
  .clip .cname{font-size:12px;font-weight:750;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .clip .ctime{font-size:10px;color:rgba(156,163,175,.92)}
  .clip.no-trim .handle{display:none;}
  .handle{
    touch-action:none;
    position:absolute;top:0;bottom:0;width:10px;cursor:ew-resize;
    opacity:.55;
  }
  .handle.left{left:0;border-right:1px solid rgba(255,255,255,.08)}
  .handle.right{right:0;border-left:1px solid rgba(255,255,255,.08)}
  .playhead{
    position:absolute;top:0;bottom:0;width:2px;
    background:rgba(56,189,248,.9);
    box-shadow:0 0 0 1px rgba(56,189,248,.18);
    pointer-events:none;
  }

  /* Modal */
  .modal{
    position:fixed;inset:0;background:rgba(0,0,0,.62);
    display:none;align-items:center;justify-content:center;padding:18px;z-index:50;
    overflow:hidden;
  }
  .modal.show{display:flex;}
  .dialog{
    width:min(720px, 100%);
    max-height:calc(100vh - 36px);
    border-radius:20px;
    border:1px solid rgba(148,163,184,.18);
    background:linear-gradient(180deg, rgba(2,6,23,.98), rgba(2,6,23,.90));
    box-shadow:0 26px 80px rgba(0,0,0,.85);
    overflow:hidden;
    display:flex;flex-direction:column;min-height:0;
  }
  .dialog-head{
    padding:14px 14px 12px;border-bottom:1px solid rgba(148,163,184,.12);
    display:flex;align-items:flex-start;justify-content:space-between;gap:10px;
  }
  .dialog-head h2{
    margin:0;font-size:13px;letter-spacing:.12em;text-transform:uppercase;color:rgba(229,231,235,.92);
  }
  .dialog-head p{
    margin:6px 0 0;font-size:12px;color:rgba(156,163,175,.95);max-width:520px;
  }
  .xbtn{
    width:34px;height:34px;border-radius:12px;border:1px solid rgba(148,163,184,.18);
    background:rgba(15,23,42,.55);color:var(--text);cursor:pointer;
  }
  .xbtn:hover{border-color:rgba(56,189,248,.55);}
  .dialog-body{padding:14px;overflow:auto;min-height:0;}
  .dialog-foot{
    padding:12px 14px;border-top:1px solid rgba(148,163,184,.12);
    display:flex;gap:8px;justify-content:flex-end;flex-wrap:wrap;
    background:rgba(2,6,23,.35);
  }

  /* responsive: collapse right panel */
  @media (max-width: 980px){
    .workspace{grid-template-columns: 260px minmax(0,1fr); }
    .right{display:none;}
  }
  @media (max-width: 720px){
    .menubar{display:none;}
    .workspace{grid-template-columns: 1fr;}
    .left{display:none;}
  }

  /* --- Phase B Stage 5: Export Probe Strip (debug-only) --- */
  .probe-strip{
    display:flex; gap:6px; flex-wrap:wrap;
    padding:8px; margin-top:8px;
    background: rgba(255,255,255,.03);
    border:1px solid rgba(255,255,255,.10);
    border-radius: 10px;
    max-height: 220px;
    overflow:auto;
  }
  .probe-strip img{
    width: 140px;
    height: auto;
    border: 1px solid rgba(255,255,255,.18);
    border-radius: 8px;
    cursor: pointer;
  }
  .probe-strip img:hover{
    outline: 2px solid rgba(56,189,248,.65);
  }
  .probe-meta{
    display:flex; align-items:center; justify-content:space-between;
    gap:10px; margin-top:10px;
  }
  .probe-meta .mono{opacity:.9}


/* --- Help Modal (Phase 2.5 UI) --- */
body.modal-open{ overflow:hidden; }
.modal-backdrop{
  position:fixed; inset:0;
  display:none;
  align-items:center; justify-content:center;
  background:rgba(4,10,20,.62);
  backdrop-filter: blur(6px);
  z-index: 9999;
  padding: 18px;
}
.modal-backdrop.show{ display:flex; }
.help-modal{
  width:min(980px, calc(100vw - 36px));
  max-height: calc(100vh - 60px);
  overflow:hidden;
  border-radius: 18px;
  border:1px solid rgba(120,160,220,.20);
  box-shadow: 0 30px 90px rgba(0,0,0,.55);
  background:
    radial-gradient(1200px 600px at 18% 10%, rgba(80,140,255,.22), rgba(0,0,0,0) 55%),
    radial-gradient(900px 500px at 85% 20%, rgba(180,90,255,.18), rgba(0,0,0,0) 50%),
    rgba(12,18,34,.96);
}
.modal-head{
  display:flex; align-items:flex-start; justify-content:space-between;
  gap:12px;
  padding: 16px 16px 12px 16px;
  border-bottom:1px solid rgba(120,160,220,.14);
}
.modal-title{ display:flex; gap:12px; align-items:flex-start; }
.badge-pill{
  display:inline-flex; align-items:center; justify-content:center;
  height:28px; padding:0 10px;
  border-radius: 999px;
  font-weight: 700;
  letter-spacing: .2px;
  color: rgba(235,245,255,.95);
  background: linear-gradient(135deg, rgba(80,140,255,.35), rgba(180,90,255,.25));
  border: 1px solid rgba(160,200,255,.22);
}
.modal .h1{ font-size: 16px; font-weight: 800; line-height: 1.25; }
.modal .sub{ font-size: 12px; color: var(--muted); margin-top: 2px; }
.modal-close{ min-width: 40px; }
.modal-body{
  padding: 14px 16px 16px 16px;
  overflow:auto;
  max-height: calc(100vh - 210px);
}
.help-grid{
  display:grid;
  grid-template-columns: repeat(2, minmax(0,1fr));
  gap: 12px;
}
.help-card{
  border-radius: 14px;
  border: 1px solid rgba(120,160,220,.14);
  background: rgba(18,26,48,.66);
  padding: 12px 12px 10px 12px;
}
.help-card.wide{ grid-column: 1 / -1; }
.help-card h3{
  margin: 0 0 8px 0;
  font-size: 13px;
  font-weight: 800;
  color: rgba(235,245,255,.95);
}
.help-card ul{ margin: 0; padding-left: 18px; }
.help-card li{
  margin: 6px 0;
  color: rgba(230,240,255,.92);
  font-size: 12px;
  line-height: 1.35;
}
.help-card b{ color: rgba(255,255,255,.98); }
.callout{
  margin-top: 10px;
  padding: 10px 10px;
  border-radius: 12px;
  background: rgba(80,140,255,.12);
  border: 1px solid rgba(80,140,255,.24);
  font-size: 12px;
  color: rgba(235,245,255,.92);
}


/* Help Guide (tabs) */
.help-shell{
  display:grid;
  grid-template-columns: 220px minmax(0,1fr);
  gap: 12px;
  align-items:start;
}
.help-nav{
  border-radius: 14px;
  border: 1px solid rgba(120,160,220,.14);
  background: rgba(18,26,48,.50);
  padding: 10px;
  display:flex;
  flex-direction:column;
  gap: 6px;
}
.help-navbtn{
  text-align:left;
  border-radius: 12px;
  border: 1px solid rgba(120,160,220,.12);
  background: rgba(15,23,42,.30);
  color: rgba(230,240,255,.92);
  padding: 10px 10px;
  cursor:pointer;
  font-size: 12px;
  font-weight: 700;
}
.help-navbtn:hover{ border-color: rgba(56,189,248,.35); }
.help-navbtn.active{
  background: linear-gradient(135deg, rgba(80,140,255,.28), rgba(180,90,255,.18));
  border-color: rgba(160,200,255,.24);
}
.help-main{
  border-radius: 14px;
  border: 1px solid rgba(120,160,220,.14);
  background: rgba(18,26,48,.40);
  padding: 14px 14px;
  min-height: 0;
}
.help-main h3{
  margin: 0 0 10px 0;
  font-size: 14px;
  font-weight: 900;
  color: rgba(235,245,255,.95);
}
.help-main p{ margin: 0 0 10px 0; font-size: 12px; color: rgba(230,240,255,.90); line-height: 1.5; }
.help-main ul, .help-main ol{ margin: 0 0 10px 0; padding-left: 18px; }
.help-main li{ margin: 6px 0; font-size: 12px; color: rgba(230,240,255,.92); line-height: 1.45; }
.help-section{ display:none; }
.help-section.active{ display:block; }
.callout.warn{
  border: 1px solid rgba(248,113,113,.24);
  background: rgba(248,113,113,.10);
}
@media (max-width: 840px){
  .help-shell{ grid-template-columns: 1fr; }
  .help-nav{ flex-direction:row; flex-wrap:wrap; }
  .help-navbtn{ flex: 1 1 160px; }
}

.modal-foot{
  display:flex; align-items:center; justify-content:space-between;
  gap: 10px;
  padding: 12px 16px 16px 16px;
  border-top:1px solid rgba(120,160,220,.14);
}
@media (max-width: 860px){
  .help-grid{ grid-template-columns: 1fr; }
}

</style>
</head>
<body>
<div class="app">
  <div class="menubar">
    <div class="menu-item" id="fileMenu">File</div>
    <div class="menu-item">Edit</div>
    <div class="menu-item">View</div>
    <div class="menu-item">Sequence</div>
    <div class="menu-item">Graphics</div>
    <div class="menu-item" id="helpMenuBtn" title="Quick guide / controls">Help</div>
    <div class="brand">
      <span class="badge">Warcut Studio</span>
      <span class="ver">Mockup v0A ¬∑ Phase B S1</span>
    </div>
  </div>

  <div class="toolbar">
    <div class="toolcluster">
      <button class="btn primary" id="importBtn" title="Import MP4 / audio / images">+ Import</button>
      <button class="btn ghost" id="addLowerThirdBtn" title="Adds a lower third at the playhead to GFX track">+ Lower Third</button>
      <div class="sep"></div>
      <span class="chip" id="projectChip"><span class="dot ok"></span>Project: <span class="mono" id="projectName">Untitled.warcut</span></span>
      <button class="btn ghost" id="newProjectBtn" title="Start a new project (clears autosave)">New</button>
      <span class="chip" id="codecChip"><span class="dot warn"></span><span id="codecText">Codec support: unknown (import a clip)</span></span>
    </div>

    <div class="toolcluster">
      <label class="chip" title="Timeline zoom (pixels per second)">
        Zoom
        <input id="zoomScale" type="range" min="0.2" max="1000" step="0.1" value="84" style="vertical-align:middle;width:140px;margin-left:8px;">
        <span class="mono" id="zoomScaleVal">84</span> px/s
      </label>
      <button class="btn ghost" id="toggleSafeBtn" title="Toggle title-safe/action-safe guides">Safe</button>
      <button class="btn" id="helpBtn" title="Feasibility + libraries">Help</button>
      <button class="btn danger" id="exportBtn" title="Mockup export">Export</button>
    </div>
  </div>

  <div class="workspace">
    <!-- LEFT: Media bin -->
    <aside class="panel left" aria-label="Media bin">
      <div class="panel-header">
        <div class="title">Media</div>
        <div class="meta"><span class="mono" id="binCount">0</span></div>
      </div>
      <div class="panel-body">
        <div class="bin-actions">
          <button class="btn" id="addToTimelineBtn" disabled>Add to timeline</button>
          <button class="btn ghost" id="removeMediaBtn" disabled>Remove</button>
        </div>
        <div class="small" style="margin-bottom:10px">
          Import MP4 (H.264 ‚ÄúH64‚Äù is typically OK), plus separate audio files for mixing. Double‚Äëclick an item to add.
        </div>
        <div class="bin-list" id="binList">
          <div class="hint warn">
            <b>Mockup note:</b> this is a UI/interaction prototype. True Premiere‚Äëlevel editing + encoding is Phase 4+.
          </div>
        </div>
      </div>
    </aside>

    <!-- CENTER: Preview + Timeline -->
    <main class="center">
      <section class="stage" aria-label="Preview stage">
        <div class="stage-top">
          <div class="left">
            <span>Viewport</span>
            <span class="zoomchip">Time: <span class="mono" id="timeReadout">00:00.000</span></span>
            <span class="zoomchip">Playhead: <span class="mono" id="playheadSec">0.00</span>s</span>
          </div>
          <div class="right">
            <span class="zoomchip">Sequence: 1920√ó1080 (Preview)</span>
            <span class="zoomchip" id="activeClipChip">Active: ‚Äî</span>
          </div>
        </div>

        <div class="viewport">
          <div class="preview-shell" aria-label="Video preview">
            <div class="bg-layer" id="bgLayer"></div>
            <video id="previewVideo" playsinline></video>
            <div class="overlay-layer" id="overlayLayer"></div>
            <div class="safe-guide" id="safeGuide"></div>
          </div>
        </div>

        <div class="stage-bottom">
          <div class="row">
            <span class="kbd">Space</span><span>Play/Pause</span>
            <span class="kbd">‚Üê ‚Üí</span><span>Step</span>
            <span class="kbd">Click</span><span>Set playhead</span>
          </div>
          <div class="row" style="justify-content:flex-end;gap:8px;align-items:center;"><button class="btn ghost" id="masterMuteBtn" title="Toggle preview mute">üîä</button><div class="small" id="statusHint">Ready ¬∑ Import media to begin.</div></div>
        </div>
      </section>

      <section class="timeline" id="timeline">
        <div class="timeline-resize" id="timelineResize" title="Drag to resize timeline height"></div>

        <div class="timeline-top">
          <div class="transport">
            <div class="tbtn" id="stepBack" title="Step back">‚ü®</div>
            <div class="tbtn primary" id="playBtn" title="Play/Pause">‚ñ∂</div>
            <div class="tbtn" id="stopBtn" title="Stop">‚ñ†</div>
            <div class="tbtn" id="stepFwd" title="Step forward">‚ü©</div>
            <div class="sep"></div>
            <span class="chip">Length: <span class="mono" id="timelineLen">0.00</span>s</span>
          </div>
          <div class="toolcluster">
            <button class="btn ghost" id="splitBtn" title="Mock: split selected clip at playhead">Split</button>
            <button class="btn ghost" id="deleteBtn" title="Delete selected clip">Delete</button>
            <button class="btn ghost" id="snapBtn" title="Toggle snapping (mock)">Snap: <span id="snapState">On</span></button>
            <button class="btn ghost" id="rippleBtn" title="Ripple trim (v1): keep adjacent clips attached when trimming right edge">Ripple: <span id="rippleState">Off</span></button>
            <button class="btn ghost" id="undoBtn" title="Undo (Ctrl+Z)">Undo</button>
            <button class="btn ghost" id="redoBtn" title="Redo (Ctrl+Y)">Redo</button>
          </div>
        </div>

        <div class="timeline-main">
          <div class="tracklist">
            <div class="track">
              <div class="name">V1 ‚Äî Video</div>
              <div class="meta">
                <span class="pillmini">Clips: <span class="mono" id="v1Count">0</span></span>
                <span class="pillmini">Mode: playlist</span>
              </div>
            </div>
            <div class="track">
              <div class="name">GFX ‚Äî Lower Thirds</div>
              <div class="meta">
                <span class="pillmini">Items: <span class="mono" id="gfxCount">0</span></span>
                <span class="pillmini">HTML overlay</span>
              </div>
            </div>
            <div class="track">
              <div class="name">A1 ‚Äî Audio</div>
              <div class="meta">
                <span class="pillmini">Clips: <span class="mono" id="a1Count">0</span></span>
                <span class="pillmini">WebAudio</span>
              </div>
            </div>
            <div class="hint">
              <b>Scroll rules:</b> Timeline and panels are scrollable. Page is fixed to viewport (no body overflow).
            </div>
          </div>

          <div class="frames">
            <div class="ruler" id="ruler"></div>
            <div class="lane-scroll" id="laneScroll">
              <div class="lanes" id="lanes">
                <div class="playhead" id="playhead"></div>

                <div class="lane" id="laneV1" data-track="v1" aria-label="V1"></div>
                <div class="lane" id="laneGFX" data-track="gfx" aria-label="GFX"></div>
                <div class="lane" id="laneA1" data-track="a1" aria-label="A1"></div>
              </div>
            </div>
          </div>
        </div>
      </section>
    </main>

    <!-- RIGHT: Inspector -->
    <aside class="panel right" aria-label="Inspector">
      <div class="panel-header">
        <div class="title">Inspector</div>
        <div class="meta">v0A</div>
      </div>

      <div class="tabs">
        <div class="tab active" data-tab="project">Project</div>
        <div class="tab" data-tab="clip">Clip</div>
        <div class="tab" data-tab="gfx">Lower Third</div>
      </div>

      <div class="panel-body">
        <div class="pane active" id="pane-project">
          <div class="block">
            <h3>Project</h3>
            <div class="field">
              <label>Project name</label>
              <input type="text" id="projectNameInput" value="Untitled.warcut" maxlength="64" />
            </div>
            <div style="height:10px"></div>
            <div class="grid2">
              <div class="field">
                <label>FPS (preview)</label>
                <select id="fpsSelect">
                  <option value="24">24</option>
                  <option value="30" selected>30</option>
                  <option value="60">60</option>
                </select>
              </div>
              <div class="field">
                <label>Audio master</label>
                <select id="audioMaster">
                  <option value="webaudio" selected>WebAudio</option>
                  <option value="clip">Clip audio only</option>
                </select>
              </div>
            </div>
            <div style="height:10px"></div>
            <div class="hint">
              <b>Premiere parity (mockup):</b> bins, tracks, selection, playhead, overlays. Export is intentionally stubbed.
            </div>
          </div>

          <div class="block">
            <h3>Feasibility</h3>
            <div class="hint warn">
              <b>Browser reality:</b> MP4/H.264 decode is handled by the browser. If a clip is HEVC/H.265, it may fail depending on OS/browser.
              For true ‚Äúimport anything + export MP4‚Äù, you typically need <span class="mono">ffmpeg.wasm</span> (large) or a server backend.
            </div>
          </div>
        </div>

        <div class="pane" id="pane-clip">
          <div class="block">
            <h3>Selected clip</h3>
            <div class="small" id="clipNone">No clip selected.</div>

            <div id="clipFields" style="display:none">
              <div class="grid2">
                <div class="field">
                  <label>Start (s)</label>
                  <input type="number" id="clipStart" min="0" step="0.01" />
                </div>
                <div class="field">
                  <label>Duration (s)</label>
                  <input type="number" id="clipDur" min="0.1" step="0.01" />
                </div>
              </div>
              <div style="height:10px"></div>
              <div class="grid2">
                <div class="field">
                  <label>In (s)</label>
                  <input type="number" id="clipIn" min="0" step="0.01" />
                </div>
                <div class="field">
                  <label>Out (s)</label>
                  <input type="number" id="clipOut" min="0" step="0.01" />
                </div>
              </div>
              <div style="height:10px"></div>
              <div class="row">
                <button class="btn" id="applyClipBtn">Apply</button>
                <button class="btn ghost" id="muteClipBtn">Audio: <span id="muteClipState">Muted</span></button>
              </div>
              <div class="hint" style="margin-top:10px">
                In/Out controls are ‚Äúsource trim‚Äù (what portion of the file is used). Start/Duration are timeline placement.
              </div>
            </div>
          </div>
        </div>

        <div class="pane" id="pane-gfx">
          <div class="block">
            <h3>Lower third</h3>
            <div class="small" id="gfxNone">No GFX item selected.</div>

            <div id="gfxFields" style="display:none">
              <div id="gfxTextFields">
              <div class="field">
                <label>Kicker</label>
                <input type="text" id="gfxKicker" maxlength="48" />
              </div>
              <div style="height:10px"></div>
              <div class="field">
                <label>Title</label>
                <input type="text" id="gfxTitle" maxlength="64" />
              </div>
              <div style="height:10px"></div>
              <div class="field">
                <label>Subtitle</label>
                <input type="text" id="gfxSub" maxlength="80" />
              </div>
            </div>

            <div id="gfxImageFields" style="display:none">
              <div class="grid2">
                <div class="field">
                  <label>Layer</label>
                  <select id="gfxLayer">
                    <option value="overlay" selected>Overlay</option>
                    <option value="bg">Background</option>
                  </select>
                </div>
                <div class="field">
                  <label>Fit</label>
                  <select id="gfxFit">
                    <option value="contain" selected>Contain</option>
                    <option value="cover">Cover</option>
                  </select>
                </div>
              </div>
              <div style="height:10px"></div>
              <div class="field">
                <label>Opacity</label>
                <input type="number" id="gfxOpacity" min="0" max="1" step="0.05" />
              </div>
              <div class="hint" style="margin-top:8px">
                Background renders under the video. For a narration-only export, set Layer = Background.
              </div>
            </div>

<div class="grid2">
                <div class="field">
                  <label>Start (s)</label>
                  <input type="number" id="gfxStart" min="0" step="0.01" />
                </div>
                <div class="field">
                  <label>Duration (s)</label>
                  <input type="number" id="gfxDur" min="0.1" step="0.01" />
                </div>
              </div>

              <div style="height:10px"></div>
              <div class="grid2">
                <div class="field">
                  <label>X (left %)</label>
                  <input type="number" id="gfxX" min="-50" max="150" step="0.1" />
                </div>
                <div class="field">
                  <label>Y (bottom %)</label>
                  <input type="number" id="gfxY" min="-50" max="150" step="0.1" />
                </div>
              </div>

              <div style="height:10px"></div>
              <div class="grid2">
                <div class="field">
                  <label>Scale</label>
                  <input type="number" id="gfxScale" min="0.25" max="3" step="0.05" />
                </div>
                <div class="field">
                  <label>Motion</label>
                  <select id="gfxMotion">
                    <option value="none">None</option>
                    <option value="fade" selected>Fade</option>
                    <option value="slide">Slide</option>
                  </select>
                </div>
              </div>

              <div style="height:10px"></div>
              <div class="row">
                <button class="btn" id="applyGfxBtn">Apply</button>
                <button class="btn ghost" id="previewGfxBtn">Preview: <span id="previewGfxState">On</span></button>
              </div>
              
              <div style="height:10px"></div>
              <div class="row">
                <button class="btn ghost" id="gfxEnabledBtn">Enabled: <span id="gfxEnabledState">On</span></button>
                <button class="btn ghost" id="gfxSoloBtn">Solo: <span id="gfxSoloState">Off</span></button>
              </div>
<div class="hint" style="margin-top:10px">
                Rendering is HTML/CSS over the preview. For ‚Äúburn-in export‚Äù you‚Äôd render frames + encode (Phase 4).
              </div>
            </div>
          </div>

          <div class="block" id="gfxPresetsBlock">
            <h3>Presets</h3>
            <div class="row">
              <button class="btn ghost" id="presetNews">News</button>
              <button class="btn ghost" id="presetCine">Cine</button>
              <button class="btn ghost" id="presetMinimal">Minimal</button>
            </div>
            <div class="small" style="margin-top:8px">Presets adjust styling (kicker/title/sub). They don‚Äôt change timing.</div>
          </div>
        </div>

      </div>
    </aside>
  </div>

  <footer class="menubar" style="border-top:1px solid var(--border);border-bottom:none;">
    <div><span class="dot ok"></span><strong>Warcut Studio</strong> ¬∑ Preview + Timeline + Lower Thirds (mock)</div>
    <div class="brand">
      <span class="ver">Viewport-safe: body overflow hidden ¬∑ panels scroll</span>
    </div>
  </footer>
</div>

<input id="fileInput" type="file" accept="video/mp4,audio/*,image/*" multiple style="display:none" />
<input id="projectInput" type="file" accept="application/json,.json,.warcut" style="display:none" />


<!-- Export modal -->
<div class="modal" id="exportModal" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="dialog">
    <div class="dialog-head">
      <div>
        <h2>Export (Stub)</h2>
        <p>
          This mockup doesn‚Äôt encode MP4. It can export a JSON project file (timeline + overlays) so a renderer (ffmpeg/server) can rebuild the edit.
        </p>
      </div>
      <button class="xbtn" id="exportClose" aria-label="Close">‚úï</button>
    </div>
    <div class="dialog-body">
      <div class="block">
        <h3>Export options</h3>
        <div class="row">
          <button class="btn primary" id="exportJsonBtn">Download Project JSON</button>
          <button class="btn ghost" id="importProjectJsonBtn" title="Load a .warcut JSON into this session">Load Project JSON</button>
          <button class="btn ghost" id="exportWebmBtn" title="Experimental: in-browser export via ffmpeg.wasm">Export MP4 (experimental)</button>
          <button class="btn ghost" id="exportFrameBtn" title="Export PNG frame at the playhead">Export Frame (PNG)</button>
          <button class="btn ghost" id="exportProbeBtn" title="Render 8‚Äì10 overlay frames around the playhead and show as a strip">Probe Frames (PNG strip)</button>
        
        <div class="probe-meta">
          <div class="small mono" id="exportProbeStatus">Probe: idle</div>
          <button class="btn ghost" id="exportProbeClearBtn" title="Clear probe thumbnails">Clear Probe</button>
        </div>
        <div id="exportProbeStrip" class="probe-strip" aria-label="Overlay probe frames"></div>

</div>
        <div class="hint warn" style="margin-top:10px">
          WebM export is experimental in this prototype (powered by <span class="mono">ffmpeg.wasm</span>). MP4 encoding + muxing is still Phase 4.
          If you want ‚ÄúPremiere-like reliability‚Äù, a server render backend is the pragmatic route.
        </div>
      </div>
    </div>
    <div class="dialog-foot">
      <button class="btn ghost" id="exportOk">Close</button>
    </div>
  </div>
</div>


<!-- Codec report modal -->
<div class="modal" id="codecModal" role="dialog" aria-modal="true" aria-hidden="true">
  <div class="dialog">
    <div class="dialog-head">
      <div>
        <h2>Codec / Playback Report</h2>
        <p>
          Browser preview depends on the browser‚Äôs built-in decoders. This report shows what the browser claims it can play, plus a quick
          ‚Äúdid this file load?‚Äù probe.
        </p>
      </div>
      <button class="xbtn" id="codecClose" aria-label="Close">‚úï</button>
    </div>
    <div class="dialog-body">
      <div class="block">
        <h3>Selected media</h3>
        <div class="small" id="codecReport">
          Import/select a video to view its report.
        </div>
      </div>
      <div class="block">
        <h3>Quick recommendations</h3>
        <div class="small">
          ‚Ä¢ For best compatibility: MP4 (H.264/AVC) + AAC audio.<br>
          ‚Ä¢ If a file won‚Äôt preview, use Proxy Mode (planned) or transcode to WebM for preview.<br>
          ‚Ä¢ Bandicam NVENC H.264 should preview in Chrome/Edge on most systems.
        </div>
      </div>
    </div>
    <div class="dialog-foot">
      <button class="btn ghost" id="codecOk">Close</button>
    </div>
  </div>
</div>




<!-- Help / Guide Modal -->
<div class="modal-backdrop" id="helpModalBackdrop" aria-hidden="true">
  <div class="help-modal" id="helpModal" role="dialog" aria-modal="true" aria-labelledby="helpModalTitle">
    <div class="modal-head">
      <div class="modal-title">
        <div class="badge-pill">Help</div>
        <div>
          <div id="helpModalTitle" class="h1">Warcut Studio ¬∑ Quick Guide</div>
          <div class="sub">Controls, workflow tips, and known quirks (mockup-first ¬∑ local-first)</div>
        </div>
      </div>
      <button class="btn ghost modal-close" id="helpModalClose" title="Close (Esc)">‚úï</button>
    </div>

    <div class="modal-body">
      <div class="help-shell">
        <aside class="help-nav" aria-label="Help topics">
          <button class="help-navbtn active" type="button" data-help-tab="getting-started">Getting Started</button>
          <button class="help-navbtn" type="button" data-help-tab="import">Importing Media</button>
          <button class="help-navbtn" type="button" data-help-tab="timeline">Timeline Editing</button>
          <button class="help-navbtn" type="button" data-help-tab="graphics">Graphics & Overlays</button>
          <button class="help-navbtn" type="button" data-help-tab="viewport">Viewport Controls</button>
          <button class="help-navbtn" type="button" data-help-tab="export">Exporting & Probing</button>
          <button class="help-navbtn" type="button" data-help-tab="quirks">Known Quirks</button>
          <button class="help-navbtn" type="button" data-help-tab="roadmap">What‚Äôs Next</button>
        </aside>

        <main class="help-main" tabindex="0">
          <section class="help-section active" data-help-section="getting-started">
            <h3>Getting Started</h3>
            <p>
              Warcut Studio is a single-file, local-first editor mockup: import media, assemble a timeline, layer overlays (lower thirds + PNG),
              and export MP4 with FFmpeg.wasm. It‚Äôs designed to be viewport-safe and run in a browser.
            </p>
            <ul>
              <li><b>Serve over http(s)</b> for export reliability (FFmpeg workers/wasm are happier on a real origin than <span class="mono">file://</span>).</li>
              <li>Use the top toolbar for <b>Import</b>, <b>Add Lower Third</b>, <b>Safe</b> guides, and <b>Export</b>.</li>
              <li>The left panel is your <b>Media Bin</b>. Select an item, then <b>Add to Timeline</b>.</li>
            </ul>
          </section>

          <section class="help-section" data-help-section="import">
            <h3>Importing Media</h3>
            <ol>
              <li>Click <b>Import</b> (top toolbar).</li>
              <li>Select files:
                <ul>
                  <li><b>Video</b>: MP4/H.264 recommended</li>
                  <li><b>Audio</b>: MP3/WAV/etc (browser-decoded)</li>
                  <li><b>Images</b>: PNG/JPG (PNG recommended for overlays)</li>
                </ul>
              </li>
              <li>Imported items appear in the <b>Media Bin</b> with metadata (duration / dimensions).</li>
              <li>Select an item ‚Üí click <b>Add to Timeline</b>:
                <ul>
                  <li>Video goes to <b>V1</b></li>
                  <li>Audio goes to <b>A1</b></li>
                  <li>Images go to <b>GFX</b> as an image overlay clip</li>
                </ul>
              </li>
            </ol>
          </section>

          <section class="help-section" data-help-section="timeline">
            <h3>Timeline Editing</h3>
            <ul>
              <li><b>Select</b>: click a clip.</li>
              <li><b>Move</b>: drag a selected clip left/right to change start time.</li>
              <li><b>Trim</b>: drag clip edges (video + GFX). (Audio duration is fixed to the file right now.)</li>
              <li><b>Delete</b>: select a clip then press <b>Delete</b> or use the toolbar <b>Delete</b> button.</li>
              <li><b>Split</b>: use <b>Split</b> at the playhead (if enabled in this build).</li>
            </ul>

            <div class="callout">
              <b>Timeline navigation shortcuts</b><br>
              ‚Ä¢ <b>Wheel</b>: pan horizontally<br>
              ‚Ä¢ <b>Alt + Wheel</b>: zoom timeline<br>
              ‚Ä¢ <b>Ctrl + Shift + Wheel</b> (while cursor is over the timeline): scroll vertically between tracks (V1 ‚áÑ GFX ‚áÑ A1)
            </div>
          </section>

          <section class="help-section" data-help-section="graphics">
            <h3>Graphics & Overlays</h3>
            <ul>
              <li><b>Lower Third</b>: click <b>Add Lower Third</b>. A GFX clip is added. Select it and edit text in the <b>Graphics</b> panel.</li>
              <li><b>PNG Overlay</b>: import a PNG ‚Üí <b>Add to Timeline</b> (it becomes a GFX clip).</li>
              <li><b>Reposition / Scale</b>: select an overlay and drag it in the viewport. Use the corner handle to scale (if enabled in your build).</li>
              <li><b>Background PNG</b>: select the PNG GFX clip ‚Üí in <b>Graphics</b> set <b>Layer = Background</b>.
                Background renders <b>behind video</b> and defaults to <b>full-frame ‚Äúcover‚Äù</b>.</li>
            </ul>
          </section>

          <section class="help-section" data-help-section="viewport">
            <h3>Viewport Controls</h3>
            <p>The preview viewport is your ‚Äúworkspace camera‚Äù. These controls do not change export ‚Äî they help you see/align things.</p>
            <ul>
              <li><b>Ctrl + click-drag</b>: zoom the viewport (drag up = zoom in, drag down = zoom out)</li>
              <li><b>Alt + click-drag</b>: pan the viewport</li>
              <li><b>Double-click</b> in the viewport: reset view</li>
              <li><b>Safe</b> button (toolbar): toggle title-safe/action-safe guides</li>
            </ul>
          </section>

          <section class="help-section" data-help-section="export">
            <h3>Exporting & Probing</h3>
            <ol>
              <li>Click <b>Export</b>.</li>
              <li><b>IMPORTANT (for now):</b> before exporting, run <b>Probe Frames</b> / <b>Probe Strip</b>
                to confirm your <b>PNG background</b> and <b>lower thirds</b> are positioned correctly.</li>
              <li>If the PNG background is not centered the way you expect, adjust and probe again. (We‚Äôll improve this later.)</li>
              <li>Export MP4. If there is audio on <b>A1</b>, it <b>replaces</b> the video‚Äôs audio in the final MP4.</li>
            </ol>

            <div class="callout warn">
              Tip: If export fails on a server refresh, it‚Äôs often because previously imported media used <span class="mono">blob:</span> URLs from an older session.
              Re-import media in the current session before exporting.
            </div>
          </section>

          <section class="help-section" data-help-section="quirks">
            <h3>Known Quirks</h3>
            <ul>
              <li><b>Local assets are session-scoped</b>: refreshing the page can invalidate <span class="mono">blob:</span> URLs. Re-import when needed.</li>
              <li>Very long exports can be slow (many frames). Consider shorter test ranges first.</li>
              <li>Browser codec support varies (some MP4/HEVC files may not preview).</li>
            </ul>
          </section>

          <section class="help-section" data-help-section="roadmap">
            <h3>What‚Äôs Next</h3>
            <ul>
              <li><b>Project Save/Open</b>: store timeline JSON + settings, and restore with ‚Äúmissing media‚Äù prompts.</li>
              <li><b>IndexedDB media cache</b> (optional): store imported assets (bigger than localStorage).</li>
              <li><b>Export UI</b>: range export, progress, cancel, and clearer ‚Äúprobe before export‚Äù guidance.</li>
            </ul>
          </section>
        </main>
      </div>
</div>

    <div class="modal-foot">
      <div class="sub">Close with <b>Esc</b>, click outside, or use the ‚úï button.</div>
      <button class="btn primary" id="helpModalGotIt">Got it</button>
    </div>
  </div>
</div>


<script type="module">
  /* =====================
     FFmpeg.wasm helpers (experimental export)
     Notes:
     - Must be served over http(s) (file:// won't work for Workers/wasm).
     - Best reliability: host @ffmpeg/ffmpeg on *your* domain (same-origin worker).
  ====================== */

  let __FFmpegClass = null;
  let __fetchFile = null;
  let __toBlobURL = null;
  let __depsLoaded = false;

  
  
  // On-demand FFmpeg script loader (prevents startup console errors when ffmpeg.js isn't present)
  const __FFMPEG_LOCAL_SRC = "./ffmpeg/ffmpeg.js";
  let __ffmpegScriptPromise = null;

  async function __ensureFFmpegScriptLoaded(){
    if (window.FFmpegWASM && window.FFmpegWASM.FFmpeg) return;
    if (__ffmpegScriptPromise) return __ffmpegScriptPromise;
    __ffmpegScriptPromise = new Promise((resolve, reject) => {
      const s = document.createElement("script");
      s.src = __FFMPEG_LOCAL_SRC;
      s.async = true;
      s.onload = () => resolve();
      s.onerror = () => reject(new Error(
        "FFmpeg dependency missing. Place ./ffmpeg/ffmpeg.js next to this HTML (in a ./ffmpeg/ folder), or run Warcut via a local web server that serves that path."
      ));
      document.head.appendChild(s);
    });
    return __ffmpegScriptPromise;
  }async function __loadFFmpegDeps(){
    if (__depsLoaded) return;
    await __ensureFFmpegScriptLoaded();

    if (!window.FFmpegWASM || !window.FFmpegWASM.FFmpeg){
      throw new Error("FFmpeg library not found after attempting to load ./ffmpeg/ffmpeg.js. See console for setup instructions.");
    }
    __FFmpegClass = window.FFmpegWASM.FFmpeg;

    // Minimal fetchFile replacement (no @ffmpeg/util needed)
    __fetchFile = async (input) => {
      if (input instanceof Uint8Array) return input;
      if (typeof input === "string"){
        const res = await fetch(input);
        return new Uint8Array(await res.arrayBuffer());
      }
      if (input && typeof input.arrayBuffer === "function"){
        return new Uint8Array(await input.arrayBuffer());
      }
      throw new Error("Unsupported input type for fetchFile");
    };

    __depsLoaded = true;
  }

  // ---- Chunked WASM loader (Cloudflare 25MB-per-file friendly) ----
  // Put these files on your site:
  //   /ffmpeg/ffmpeg-core.wasm.part00, /ffmpeg/ffmpeg-core.wasm.part01, /ffmpeg/ffmpeg-core.wasm.part02, /ffmpeg/ffmpeg-core.wasm.part03
  const __WASM_PART_URLS = ["/ffmpeg/ffmpeg-core.wasm.part00", "/ffmpeg/ffmpeg-core.wasm.part01", "/ffmpeg/ffmpeg-core.wasm.part02", "/ffmpeg/ffmpeg-core.wasm.part03"];
  let __wasmBlobURL = null;

  async function __getChunkedWasmURL(){
    if (__wasmBlobURL) return __wasmBlobURL;
    const bufs = [];
    let total = 0;
    for (const url of __WASM_PART_URLS){
      const res = await fetch(url);
      if (!res.ok) throw new Error("Missing WASM chunk: " + url + " (" + res.status + ")");
      const ab = await res.arrayBuffer();
      bufs.push(new Uint8Array(ab));
      total += ab.byteLength;
    }
    const joined = new Uint8Array(total);
    let off = 0;
    for (const b of bufs){ joined.set(b, off); off += b.byteLength; }
    __wasmBlobURL = URL.createObjectURL(new Blob([joined], { type: "application/wasm" }));
    return __wasmBlobURL;
  }
  // ---- /Chunked WASM loader ----


  // Use a module Worker (same-origin via blob:) so we can import the ESM core (ffmpeg-core*.js).
  // This avoids classic-worker importScripts() issues with ESM core files.
  let __classWorkerURL = null;

  function __getFFmpegClassWorkerURL(origin){
    if (__classWorkerURL) return __classWorkerURL;

    const ORIGIN = String(origin || "");
    const src = `
      const FFMessageType = {
        LOAD: "LOAD",
        EXEC: "EXEC",
        FFPROBE: "FFPROBE",
        WRITE_FILE: "WRITE_FILE",
        READ_FILE: "READ_FILE",
        DELETE_FILE: "DELETE_FILE",
        RENAME: "RENAME",
        CREATE_DIR: "CREATE_DIR",
        LIST_DIR: "LIST_DIR",
        DELETE_DIR: "DELETE_DIR",
        ERROR: "ERROR",
        PROGRESS: "PROGRESS",
        LOG: "LOG",
        MOUNT: "MOUNT",
        UNMOUNT: "UNMOUNT"
      };

      const ERROR_UNKNOWN_MESSAGE_TYPE = new Error("unknown message type");
      const ERROR_NOT_LOADED = new Error("ffmpeg is not loaded, call \`await ffmpeg.load()\` first");
      const ERROR_IMPORT_FAILURE = new Error("failed to import ffmpeg-core.js");

      let ffmpeg = null;

      const load = async ({ coreURL: _coreURL, wasmURL: _wasmURL, workerURL: _workerURL }) => {
        const first = !ffmpeg;

        // Force same-origin defaults
        if (!_coreURL) _coreURL = ORIGIN + "/ffmpeg/ffmpeg-core.min.js";
        if (!_wasmURL) _wasmURL = ORIGIN + "/ffmpeg/ffmpeg-core.wasm";

        // IMPORTANT: This is a MODULE worker. Use dynamic import (NOT importScripts).
        const mod = await import(/* @vite-ignore */ _coreURL);
        const createFFmpegCore = (mod && (mod.default || mod.createFFmpegCore)) || self.createFFmpegCore;
        if (!createFFmpegCore) throw ERROR_IMPORT_FAILURE;

        const coreURL = _coreURL;
        const wasmURL = _wasmURL || _coreURL.replace(/.js$/g, ".wasm");
        const workerURL = _workerURL || _coreURL.replace(/.js$/g, ".worker.js");

        ffmpeg = await createFFmpegCore({
          // Encode wasmURL/workerURL for locateFile
          mainScriptUrlOrBlob: coreURL + "#" + btoa(JSON.stringify({ wasmURL, workerURL }))
        });

        ffmpeg.setLogger((data) => self.postMessage({ type: FFMessageType.LOG, data }));
        ffmpeg.setProgress((data) => self.postMessage({ type: FFMessageType.PROGRESS, data }));

        return first;
      };

      const exec = ({ args, timeout = -1 }) => {
        ffmpeg.setTimeout(timeout);
        ffmpeg.exec(...args);
        const ret = ffmpeg.ret;
        ffmpeg.reset();
        return ret;
      };

      const ffprobe = ({ args, timeout = -1 }) => {
        ffmpeg.setTimeout(timeout);
        ffmpeg.ffprobe(...args);
        const ret = ffmpeg.ret;
        ffmpeg.reset();
        return ret;
      };

      const writeFile = ({ path, data }) => {
        ffmpeg.FS.writeFile(path, data);
        return true;
      };

      const readFile = ({ path, encoding }) => ffmpeg.FS.readFile(path, { encoding });

      const deleteFile = ({ path }) => {
        ffmpeg.FS.unlink(path);
        return true;
      };

      const rename = ({ oldPath, newPath }) => {
        ffmpeg.FS.rename(oldPath, newPath);
        return true;
      };

      const createDir = ({ path }) => {
        ffmpeg.FS.mkdir(path);
        return true;
      };

      const listDir = ({ path }) => {
        const names = ffmpeg.FS.readdir(path);
        const nodes = [];
        for (const name of names) {
          const stat = ffmpeg.FS.stat(path + "/" + name);
          const isDir = ffmpeg.FS.isDir(stat.mode);
          nodes.push({ name, isDir });
        }
        return nodes;
      };

      const deleteDir = ({ path }) => {
        ffmpeg.FS.rmdir(path);
        return true;
      };

      const mount = ({ fsType, options, mountPoint }) => {
        const str = fsType;
        const fs = ffmpeg.FS.filesystems[str];
        if (!fs) return false;
        ffmpeg.FS.mount(fs, options, mountPoint);
        return true;
      };

      const unmount = ({ mountPoint }) => {
        ffmpeg.FS.unmount(mountPoint);
        return true;
      };

      self.onmessage = async ({ data: { id, type, data: _data } }) => {
        const trans = [];
        let data;

        try {
          if (type !== FFMessageType.LOAD && !ffmpeg) throw ERROR_NOT_LOADED;

          switch (type) {
            case FFMessageType.LOAD:
              data = await load(_data || {});
              break;
            case FFMessageType.EXEC:
              data = exec(_data);
              break;
            case FFMessageType.FFPROBE:
              data = ffprobe(_data);
              break;
            case FFMessageType.WRITE_FILE:
              data = writeFile(_data);
              break;
            case FFMessageType.READ_FILE:
              data = readFile(_data);
              break;
            case FFMessageType.DELETE_FILE:
              data = deleteFile(_data);
              break;
            case FFMessageType.RENAME:
              data = rename(_data);
              break;
            case FFMessageType.CREATE_DIR:
              data = createDir(_data);
              break;
            case FFMessageType.LIST_DIR:
              data = listDir(_data);
              break;
            case FFMessageType.DELETE_DIR:
              data = deleteDir(_data);
              break;
            case FFMessageType.MOUNT:
              data = mount(_data);
              break;
            case FFMessageType.UNMOUNT:
              data = unmount(_data);
              break;
            default:
              throw ERROR_UNKNOWN_MESSAGE_TYPE;
          }
        } catch (e) {
          self.postMessage({ id, type: FFMessageType.ERROR, data: String(e && e.message ? e.message : e) });
          return;
        }

        if (data instanceof Uint8Array) trans.push(data.buffer);
        self.postMessage({ id, type, data }, trans);
      };
    `;

    const blob = new Blob([src], { type: "text/javascript" });
    __classWorkerURL = URL.createObjectURL(blob);
    return __classWorkerURL;
  }

  let __ffmpeg = null;
  let __ffmpegLoadPromise = null;
  let __logHooked = false;

  async function __ensureFFmpeg(onLog){
    if (location.protocol === "file:"){
      throw new Error("Serve this page over http(s). (file:// cannot load Workers/wasm reliably.)");
    }

    await __loadFFmpegDeps();
    if (!__ffmpeg) __ffmpeg = new __FFmpegClass();

    if (!__logHooked){
      __ffmpeg.on("log", ({ message }) => { if (onLog) onLog(message); });
      __logHooked = true;
    }

    if (!__ffmpegLoadPromise){
      // Single-thread core (no COOP/COEP required; slower but simpler)
      __ffmpegLoadPromise = (async () => {
        const origin = location.origin;
        const classWorkerURL = __getFFmpegClassWorkerURL(origin);
        // IMPORTANT: use ESM core (ffmpeg-core*.js) via module worker
        await __ffmpeg.load({
          classWorkerURL,
          coreURL: origin + "/ffmpeg/ffmpeg-core.min.js",
          wasmURL: await __getChunkedWasmURL()
        });
      })();
    }

    await __ffmpegLoadPromise;
    return __ffmpeg;
  }

  /* ==========================================================
     Phase B ‚Äî Export-Safe Rasterization Pipeline
     Stage 1: Unified Overlay Rasterizer (overlay -> transparent PNG)
     Why: ONE code-path for any overlay rasterization so export + frame grabs match.
     Scope (Stage 1): Lower Thirds only (static), shared by FFmpeg export + Export Frame.
  ========================================================== */
  const __warcutRaster = (() => {
    const safeNum = (v, d=0) => (Number.isFinite(+v) ? +v : d);
    const clamp = (v,a,b) => Math.max(a, Math.min(b, v));

    function __roundRect(ctx, x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y,   x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x,   y+h, rr);
      ctx.arcTo(x,   y+h, x,   y,   rr);
      ctx.arcTo(x,   y,   x+w, y,   rr);
      ctx.closePath();
    }

    function drawLowerThird(ctx, item, W, H){
      if (!ctx || !W || !H) return;

      const xPct = safeNum(item?.x, safeNum(item?.xPct, 4.5));
      const yPct = safeNum(item?.y, safeNum(item?.yPct, 7));
      const scale = clamp(safeNum(item?.scale, 1), 0.25, 3);

      const preset = String(item?.stylePreset || item?.preset || "news");

      const boxW = Math.min(W * 0.72, 1100 * scale);
      const padX = 16 * scale;
      const padY = 12 * scale;
      const gap = 6 * scale;

      const kicker = String(item?.kicker ?? "");
      const title = String(item?.title ?? "");
      const subtitle = String(item?.subtitle ?? "");

      const kickerSize = 18 * scale;
      const titleSize  = 34 * scale;
      const subSize    = 22 * scale;

      let boxH = padY * 2 + (kicker ? kickerSize + gap : 0) + (title ? titleSize + gap : 0) + (subtitle ? subSize : 0);
      boxH = Math.max(boxH, 64 * scale);

      const left = W * (xPct/100);
      const bottomMargin = H * (yPct/100);
      const top = H - bottomMargin - boxH;

      const radius = 14 * scale;

      // preset styling
      const accent = (preset === "cine")
        ? "rgba(229,237,247,0.92)"
        : (preset === "minimal")
          ? "rgba(56,189,248,0.55)"
          : "rgba(56,189,248,0.72)";

      const border = (preset === "minimal") ? "rgba(148,163,184,0.25)" : "rgba(56, 189, 248, 0.55)";
      const bgA = (preset === "cine") ? "rgba(2, 6, 23, 0.92)" : "rgba(2, 6, 23, 0.84)";
      const bgB = (preset === "cine") ? "rgba(2, 6, 23, 0.72)" : "rgba(2, 6, 23, 0.52)";

      const grad = ctx.createLinearGradient(left, top, left + boxW, top + boxH);
      grad.addColorStop(0, bgA);
      grad.addColorStop(1, bgB);

      // shadow
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.45)";
      ctx.shadowBlur = 24 * scale;
      ctx.shadowOffsetY = 10 * scale;
      __roundRect(ctx, left, top, boxW, boxH, radius);
      ctx.fillStyle = "rgba(0,0,0,0.01)";
      ctx.fill();
      ctx.restore();

      // fill
      __roundRect(ctx, left, top, boxW, boxH, radius);
      ctx.fillStyle = grad;
      ctx.fill();

      // border
      ctx.lineWidth = 1.5 * scale;
      ctx.strokeStyle = border;
      ctx.stroke();

      // accent strip (news/cine)
      let textInset = 0;
      if (preset !== "minimal"){
        const stripW = Math.max(10*scale, boxW*0.012);
        __roundRect(ctx, left, top, stripW, boxH, radius);
        ctx.fillStyle = accent;
        ctx.globalAlpha = 0.95;
        ctx.fill();
        ctx.globalAlpha = 1;
        textInset = stripW + 10*scale;
      }

      // text
      let tx = left + padX + textInset;
      let ty = top + padY;

      ctx.textBaseline = "top";

      if (kicker){
        ctx.font = `600 ${kickerSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillStyle = "rgba(156, 170, 199, 0.95)";
        ctx.fillText(kicker.toUpperCase(), tx, ty);
        ty += kickerSize + gap;
      }
      if (title){
        ctx.font = `800 ${titleSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillStyle = "rgba(229, 237, 247, 0.98)";
        ctx.fillText(title, tx, ty);
        ty += titleSize + gap;
      }
      if (subtitle){
        ctx.font = `600 ${subSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillStyle = "rgba(156, 170, 199, 0.98)";
        ctx.fillText(subtitle, tx, ty);
      }
    }

    function drawImageOverlay(ctx, item, W, H){
      if (!ctx || !W || !H) return;
      const img = item?.img || item?.image;
      if (!img) return;

      const xPct = safeNum(item?.xPct, safeNum(item?.x, 4.5));
      const yPct = safeNum(item?.yPct, safeNum(item?.y, 7));
      const scale = clamp(safeNum(item?.scale, 1), 0.05, 12);
      const opacity = clamp(safeNum(item?.opacity, safeNum(item?.asset?.opacity, 1)), 0, 1);
      const fit = String(item?.fit || item?.asset?.fit || "contain");
      const maxWPct = clamp(safeNum(item?.maxWPct, 35), 1, 100);
      const maxHPct = clamp(safeNum(item?.maxHPct, 35), 1, 100);

      const iw = (img.naturalWidth || img.width || 1);
      const ih = (img.naturalHeight || img.height || 1);
      if (!iw || !ih) return;

      const maxW = W * (maxWPct / 100);
      const maxH = H * (maxHPct / 100);

      let fitScale = 1;
      if (fit !== "none"){
        const s1 = maxW / iw;
        const s2 = maxH / ih;
        fitScale = (fit === "cover") ? Math.max(s1, s2) : Math.min(s1, s2);
      }
      const s = fitScale * scale;
      const dw = iw * s;
      const dh = ih * s;

      const left = (W * (xPct / 100));
      const bottom = (H * (yPct / 100));
      const top = (H - bottom - dh);

      ctx.save();
      ctx.globalAlpha = opacity;
      try{ ctx.imageSmoothingEnabled = true; }catch(_e){}
      ctx.drawImage(img, left, top, dw, dh);
      ctx.restore();
    }

    async function lowerThirdToPngBytes(item, W, H){
      const canvas = document.createElement("canvas");
      canvas.width = W; canvas.height = H;
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0,0,W,H);
      drawLowerThird(ctx, item, W, H);
      const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
      if (!blob) throw new Error("Overlay rasterization failed (toBlob returned null).");
      return new Uint8Array(await blob.arrayBuffer());
    }

    return { drawLowerThird, drawImageOverlay, lowerThirdToPngBytes };
  })();




  /* ==========================================================
     Phase B ‚Äî Export-Safe Rasterization Pipeline (Debug API)
     Stages 1‚Äì5: unified entry point + asset readiness + caching + schedule + PNG frames
     Notes:
     - Keeps existing interactive HTML overlay preview intact.
     - Export + debug frame probes use the rasterizer below.
  ========================================================== */

  const BASE_W = 1920;
  const BASE_H = 1080;

  const __B_safeAreaPresets = Object.freeze({
    none:   { insetPctX: 0,  insetPctY: 0  },
    title:  { insetPctX: 5,  insetPctY: 5  },   // ~90% title safe
    action: { insetPctX: 3.5,insetPctY: 3.5 }    // ~93% action safe
  });

  function __B_letterbox(targetW, targetH){
    targetW = Math.max(1, Math.floor(targetW || BASE_W));
    targetH = Math.max(1, Math.floor(targetH || BASE_H));
    const s = Math.min(targetW / BASE_W, targetH / BASE_H);
    const contentW = Math.round(BASE_W * s);
    const contentH = Math.round(BASE_H * s);
    const offX = Math.floor((targetW - contentW) / 2);
    const offY = Math.floor((targetH - contentH) / 2);
    return { s, contentW, contentH, offX, offY, targetW, targetH };
  }

  function __B_safeAreaRect(contentW, contentH, preset){
    const p = __B_safeAreaPresets[String(preset||"none")] || __B_safeAreaPresets.none;
    const insetX = (p.insetPctX/100) * contentW;
    const insetY = (p.insetPctY/100) * contentH;
    return {
      x: insetX,
      y: insetY,
      w: Math.max(0, contentW - insetX*2),
      h: Math.max(0, contentH - insetY*2)
    };
  }

  // Stage 1 helpers (base -> target mapping)
  function mapBaseToTarget(x, y, targetW, targetH, safeAreaPreset="none"){
    const lb = __B_letterbox(targetW, targetH);
    const sa = __B_safeAreaRect(lb.contentW, lb.contentH, safeAreaPreset);
    const sx = lb.s;
    const sy = lb.s;
    const tx = lb.offX + sa.x + (x * sx);
    const ty = lb.offY + sa.y + (y * sy);
    return { x: tx, y: ty, scale: lb.s, offX: lb.offX, offY: lb.offY, contentW: lb.contentW, contentH: lb.contentH, safe: sa };
  }

  function scaleBaseToTarget(s, targetW, targetH){
    const lb = __B_letterbox(targetW, targetH);
    return (Number(s)||0) * lb.s;
  }

  function __B_stableId(v){
    try{ return String(v ?? ""); }catch(_e){ return ""; }
  }

  // Stage 1: deterministic overlay ordering + solo/enabled rules
  function __B_getRenderableOverlaysAtTime(t, overlays){
    const list = Array.isArray(overlays) ? overlays.slice() : [];
    const norm = list
      .map(o => (typeof ensureOverlaySchema === "function" ? ensureOverlaySchema(o) : o))
      .filter(o => o && o.enabled);

    const anySolo = norm.some(o => o.solo);
    const filtered = anySolo ? norm.filter(o => o.solo) : norm;

    const active = filtered.filter(o => {
      const st = Number(o?.timing?.start ?? o?.start ?? 0) || 0;
      const du = Number(o?.timing?.dur ?? o?.dur ?? 0) || 0;
      const et = st + du;
      return (t >= st && t <= et);
    });

    // zIndex then stable id
    active.sort((a,b) => {
      const za = Number(a?.zIndex ?? 0) || 0;
      const zb = Number(b?.zIndex ?? 0) || 0;
      if (za !== zb) return za - zb;
      const ia = __B_stableId(a.id);
      const ib = __B_stableId(b.id);
      return ia < ib ? -1 : ia > ib ? 1 : 0;
    });

    return active;
  }

  // Stage 2: asset readiness gate
  const __B_imgCache = new Map();
  const __B_imgResolved = new Map();
  const __B_imgFailed = new Set();

  // Track blob: URLs created during THIS session only (local imports).
  // Prevents stale blob URLs (from autosave) from spamming errors.
  const __SESSION_BLOB_URLS = new Set();
  function __rememberSessionBlobUrl(u){
    try{
      const s = String(u||"");
      if (s.startsWith("blob:")) __SESSION_BLOB_URLS.add(s);
    }catch(_e){}
  }
  function __isProbablyRestorableUrl(u){
    const s = String(u||"").trim();
    if (!s) return false;
    if (s.startsWith("data:")) return true;
    if (s.startsWith("http:") || s.startsWith("https:")) return true;
    if (s.startsWith("blob:")) return __SESSION_BLOB_URLS.has(s);
    return false;
  }

  async function loadImage(url){
    const key = String(url||"").trim();
    if (!key) return null;
    if (__B_imgFailed.has(key)) return null;
    if (__B_imgCache.has(key)) return __B_imgCache.get(key);

    const p = new Promise((resolve) => {
      try{
        if (!__isProbablyRestorableUrl(key)){
          __B_imgFailed.add(key);
          return resolve(null);
        }
        const img = new Image();
        img.decoding = "async";
        img.onload = () => {
          try{ __B_imgResolved.set(key, img); }catch(_e){}
          resolve(img);
        };
        img.onerror = () => {
          __B_imgFailed.add(key);
          resolve(null);
        };
        img.src = key;
      }catch(_e){
        __B_imgFailed.add(key);
        resolve(null);
      }
    });

    __B_imgCache.set(key, p);
    return p;
  }

  function __B_getResolvedImage(url){
    const key = String(url||"").trim();
    if (!key) return null;
    return __B_imgResolved.get(key) || null;
  }

  async function ensureOverlayAssetsReady(overlays){
    // Fonts (system fonts are fine; custom fonts can be loaded by user elsewhere)
    try{
      if (document.fonts && document.fonts.ready) await document.fonts.ready;
    }catch(_e){ /* ignore */ }

    const list = Array.isArray(overlays) ? overlays : [];
    const urls = [];
    for (const o of list){
      // Prefer mediaId ‚Üí live media.url (session-only blob)
      const mid = o?.asset?.mediaId || o?.asset?.id || o?.mediaId;
      let u = "";
      if (mid){
        const mm = media.find(m => m.id === String(mid));
        u = String(mm?.url || "");
      }
      if (!u){
        u = String(o?.asset?.url || o?.assetUrl || o?.style?.imageUrl || o?.imageUrl || "");
      }
      if (u) urls.push(u);
    }
    if (!urls.length) return true;

    // Never reject‚Äîmissing assets should just be skipped.
    await Promise.all(urls.map(u => loadImage(u).catch(() => null)));
    return true;
  }

  // Stage 3: simple per-overlay full-frame cache (LRU)
  const __B_cache = new Map();
  const __B_cacheMax = 36;

  function __B_cacheGet(k){
    if (!__B_cache.has(k)) return null;
    const v = __B_cache.get(k);
    // refresh LRU order
    __B_cache.delete(k);
    __B_cache.set(k, v);
    return v;
  }

  function __B_cacheSet(k, v){
    if (__B_cache.has(k)) __B_cache.delete(k);
    __B_cache.set(k, v);
    while (__B_cache.size > __B_cacheMax){
      const firstKey = __B_cache.keys().next().value;
      __B_cache.delete(firstKey);
    }
  }

  function __B_hashOverlayForCache(o){
    // stable-ish (fast) hash key for style/transform/content
    const t = o?.transform || {};
    const s = o?.style || {};
    const a = o?.asset || {};
    const motion = o?.motion || {};
    return [
      o?.type, o?.zIndex,
      t?.xPct, t?.yPct, t?.scale,
      s?.preset, s?.kicker, s?.title, s?.subtitle,
      a?.url, a?.fit, a?.opacity,
      motion?.type || "none"
    ].map(v => String(v ?? "")).join("|");
  }


  /* ==========================================================
     Phase B ‚Äî Stage 4 / Stack 1: Overlay Time Classification (Pure Logic)
     Why: Shared, deterministic classification used by dirty scheduling + caching.
     Notes:
     - Pure logic (no DOM, no canvas) so it can move into a worker later.
     - Supports both schema styles: timing.{start,dur} and legacy {start,dur} / {end}.
  ========================================================== */

  function __B_getOverlayTimeClass(overlay, t){
    if (!overlay) return "inactive";
    t = Number(t || 0);

    const st = Number(overlay?.timing?.start ?? overlay?.start ?? 0) || 0;
    const du = Number(overlay?.timing?.dur   ?? overlay?.dur   ?? 0) || 0;

    // Prefer start+dur when dur is provided; otherwise allow explicit end.
    const explicitEnd = overlay?.timing?.end ?? overlay?.end;
    const et = (du > 0) ? (st + du) : (Number.isFinite(+explicitEnd) ? (+explicitEnd) : Infinity);

    if (t < st || t > et) return "inactive";

    // Motion primitives (Phase H compatibility)
    const mType = String(overlay?.motion?.type ?? overlay?.motion ?? "none");
    if (mType && mType !== "none") return "dynamic";

    // Keyframes (Phase I compatibility)
    if (Array.isArray(overlay?.keyframes) && overlay.keyframes.length) return "dynamic";
    if (Array.isArray(overlay?.motion?.keyframes) && overlay.motion.keyframes.length) return "dynamic";

    // Time-dependent tokens (date/time/etc) anywhere in overlay text-ish fields
    const tokenRe = /\{(time|date)\}/i;
    const maybeStrings = [
      overlay?.text,
      overlay?.style?.text,
      overlay?.style?.kicker,
      overlay?.style?.title,
      overlay?.style?.subtitle,
      overlay?.style?.headline,
      overlay?.style?.url,
      overlay?.style?.watermark
    ];
    for (const s of maybeStrings){
      if (typeof s === "string" && tokenRe.test(s)) return "dynamic";
    }

    return "static";
  }

  function __B_getActiveOverlaysAtTime(overlays, t){
    return (Array.isArray(overlays) ? overlays : [])
      .filter(o => __B_getOverlayTimeClass(o, t) !== "inactive");
  }

  // Global namespace for future stacks (does not affect runtime unless you call it)
  try{
    window.__warcutPhaseB = window.__warcutPhaseB || {};
    if (typeof window.__warcutPhaseB.getOverlayTimeClass !== "function"){
      window.__warcutPhaseB.getOverlayTimeClass = __B_getOverlayTimeClass;
    }
    if (typeof window.__warcutPhaseB.getActiveOverlaysAtTime !== "function"){
      window.__warcutPhaseB.getActiveOverlaysAtTime = __B_getActiveOverlaysAtTime;
    }
    window.__warcutPhaseB.__placeholders = window.__warcutPhaseB.__placeholders || {};
    if (!("buildFrameSignature" in window.__warcutPhaseB.__placeholders)) window.__warcutPhaseB.__placeholders.buildFrameSignature = null; // Stack 2
    if (!("buildRenderSchedule" in window.__warcutPhaseB.__placeholders)) window.__warcutPhaseB.__placeholders.buildRenderSchedule = null; // Stack 3
    if (!("rasterizeToPngFrames" in window.__warcutPhaseB.__placeholders)) window.__warcutPhaseB.__placeholders.rasterizeToPngFrames = null; // Stack 4
  }catch(_e){ /* ignore */ }

  function __B_isStaticAtTime(o, t){
    // Stack 1 classifier is the source of truth.
    try{
      return __B_getOverlayTimeClass(o, t) === "static";
    }catch(_e){
      // conservative fallback (pre-Stack behavior)
      const m = String(o?.motion?.type || o?.motion || "none");
      if (m && m !== "none") return false;
      return true;
    }
  }


  /* ==========================================================
     Phase B ‚Äî Stage 4 / Stack 2: Dirty Interval Tracker + Frame Signatures
     Goal:
       - Track "dirty" time ranges after overlay edits (export can re-render only what changed)
       - Provide a deterministic per-frame signature helper (shared by schedule/caching)
     Safety:
       - Pure logic + safe try/catch hooks.
       - No behavior changes unless you call the exposed APIs.
  ========================================================== */

  function buildFrameSignature({ t=0, overlays=[], targetW=BASE_W, targetH=BASE_H } = {}){
    t = Number(t || 0);
    const active = __B_getRenderableOverlaysAtTime(t, overlays);

    const anyDynamic = active.some(o => __B_getOverlayTimeClass(o, t) !== "static");
    if (anyDynamic){
      return {
        sig: "__DYNAMIC__",
        anyDynamic: true,
        activeCount: active.length,
        activeIds: active.map(o => String(o.id || ""))
      };
    }

    const sig = active
      .map(o => `${String(o.id||"")}:${__B_hashOverlayForCache(o)}:${targetW}x${targetH}`)
      .join(",");

    return {
      sig,
      anyDynamic: false,
      activeCount: active.length,
      activeIds: active.map(o => String(o.id || ""))
    };
  }

  function __B_isOverlayIntrinsicallyDynamic(o){
    // Intrinsic properties that make an overlay dynamic whenever it's active.
    if (!o) return false;
    const mType = String(o?.motion?.type ?? o?.motion ?? "none");
    if (mType && mType !== "none") return true;
    if (Array.isArray(o?.keyframes) && o.keyframes.length) return true;
    if (Array.isArray(o?.motion?.keyframes) && o.motion.keyframes.length) return true;

    const tokenRe = /\{(time|date)\}/i;
    const maybeStrings = [
      o?.text,
      o?.style?.text,
      o?.style?.kicker,
      o?.style?.title,
      o?.style?.subtitle,
      o?.style?.headline,
      o?.style?.url,
      o?.style?.watermark
    ];
    for (const s of maybeStrings){
      if (typeof s === "string" && tokenRe.test(s)) return true;
    }
    return false;
  }

  function createDirtyRangeTracker(){
    const rangesById = new Map();
    let rev = 0;

    const num = (v, d=0) => (Number.isFinite(+v) ? +v : d);

    function __normRange(start, end){
      start = Math.max(0, num(start, 0));
      end = Math.max(0, num(end, start));
      if (end < start) [start, end] = [end, start];
      return { start, end };
    }

    function __merge(list){
      if (!list.length) return list;
      list.sort((a,b) => (a.start - b.start) || (a.end - b.end));
      const out = [list[0]];
      for (let i=1;i<list.length;i++){
        const cur = list[i];
        const prev = out[out.length - 1];
        if (cur.start <= prev.end + 1e-6){
          prev.end = Math.max(prev.end, cur.end);
          // collapse metadata best-effort (non-critical)
          if (cur.reason && prev.reason && cur.reason !== prev.reason){
            prev.reason = prev.reason.includes(cur.reason) ? prev.reason : (prev.reason + "," + cur.reason);
          } else if (!prev.reason && cur.reason){
            prev.reason = cur.reason;
          }
          prev.ts = Math.min(prev.ts, cur.ts);
        } else {
          out.push(cur);
        }
      }
      return out;
    }

    function markRange(id, start, end, reason="edit"){
      id = String(id || "").trim();
      if (!id) return false;
      const r = __normRange(start, end);
      const item = { start: r.start, end: r.end, reason: String(reason||"edit"), ts: Date.now() };
      const list = rangesById.get(id) || [];
      list.push(item);
      rangesById.set(id, __merge(list));
      rev++;
      return true;
    }

    function markOverlayChange(overlay, reason="overlay-change"){
      if (!overlay) return false;
      const id = String(overlay?.id || "");
      const st = num(overlay?.timing?.start ?? overlay?.start, 0);
      const du = num(overlay?.timing?.dur   ?? overlay?.dur,   0);
      const explicitEnd = overlay?.timing?.end ?? overlay?.end;
      const et = (du > 0) ? (st + du) : (Number.isFinite(+explicitEnd) ? +explicitEnd : st);
      return markRange(id, st, et, reason);
    }

    function clear(id){
      if (id == null){
        rangesById.clear();
        rev++;
        return true;
      }
      id = String(id || "").trim();
      if (!id) return false;
      const ok = rangesById.delete(id);
      if (ok) rev++;
      return ok;
    }

    function get(id){
      id = String(id || "").trim();
      return (rangesById.get(id) || []).map(r => ({...r}));
    }

    function getAll(){
      const out = [];
      for (const [id, list] of rangesById.entries()){
        for (const r of list) out.push({ id, ...r });
      }
      out.sort((a,b) => (a.start - b.start) || (a.end - b.end) || String(a.id).localeCompare(String(b.id)));
      return out;
    }

    function anyDirtyAtTime(t){
      t = num(t, 0);
      for (const list of rangesById.values()){
        for (const r of list){
          if (t >= r.start && t <= r.end) return true;
        }
      }
      return false;
    }

    function isOverlayDirtyAtTime(id, t){
      id = String(id || "").trim();
      t = num(t, 0);
      const list = rangesById.get(id) || [];
      for (const r of list){
        if (t >= r.start && t <= r.end) return true;
      }
      return false;
    }

    function revision(){ return rev; }

    return { markRange, markOverlayChange, clear, get, getAll, anyDirtyAtTime, isOverlayDirtyAtTime, revision };
  }

  const __B_dirty = createDirtyRangeTracker();

  // Convert dirty ranges (seconds) into merged frame ranges [i0,i1] (inclusive)
  function buildDirtyFrameRanges({ overlays=[], fps=30, duration=0, tracker=__B_dirty } = {}){
    fps = Math.max(1, Number(fps) || 30);
    duration = Math.max(0, Number(duration) || 0);
    const total = Math.max(0, Math.ceil(duration * fps));
    const ranges = [];

    // 1) Explicit dirty intervals from tracker
    try{
      const all = tracker && typeof tracker.getAll === "function" ? tracker.getAll() : [];
      for (const r of all){
        const i0 = Math.max(0, Math.floor(Number(r.start) * fps));
        const i1 = Math.min(total - 1, Math.ceil(Number(r.end) * fps));
        if (Number.isFinite(i0) && Number.isFinite(i1) && i1 >= i0){
          ranges.push({ i0, i1, reason: String(r.reason || "edit"), id: String(r.id || "") });
        }
      }
    }catch(_e){}

    // 2) Intrinsically dynamic overlays mark their active range as always-dirty during export
    try{
      const list = Array.isArray(overlays) ? overlays : [];
      for (const o of list){
        if (!__B_isOverlayIntrinsicallyDynamic(o)) continue;
        const st = Number(o?.timing?.start ?? o?.start ?? 0) || 0;
        const du = Number(o?.timing?.dur   ?? o?.dur   ?? 0) || 0;
        const et = (du > 0) ? (st + du) : st;
        const i0 = Math.max(0, Math.floor(st * fps));
        const i1 = Math.min(total - 1, Math.ceil(et * fps));
        if (i1 >= i0){
          ranges.push({ i0, i1, reason: "dynamic", id: String(o?.id || "") });
        }
      }
    }catch(_e){}

    // Merge by i0/i1
    ranges.sort((a,b) => (a.i0 - b.i0) || (a.i1 - b.i1));
    const merged = [];
    for (const r of ranges){
      if (!merged.length){
        merged.push({ i0:r.i0, i1:r.i1, reason:r.reason });
        continue;
      }
      const prev = merged[merged.length - 1];
      if (r.i0 <= prev.i1 + 1){
        prev.i1 = Math.max(prev.i1, r.i1);
        if (r.reason && !prev.reason.includes(r.reason)) prev.reason += "," + r.reason;
      } else {
        merged.push({ i0:r.i0, i1:r.i1, reason:r.reason });
      }
    }

    return { totalFrames: total, ranges: merged };
  }

  // Expose Stack 2 APIs
  try{
    window.__warcutPhaseB = window.__warcutPhaseB || {};
    window.__warcutPhaseB.buildFrameSignature = buildFrameSignature;
    window.__warcutPhaseB.dirty = window.__warcutPhaseB.dirty || __B_dirty;
    window.__warcutPhaseB.buildDirtyFrameRanges = buildDirtyFrameRanges;

    // Mark placeholder as implemented (if present)
    if (window.__warcutPhaseB.__placeholders){
      window.__warcutPhaseB.__placeholders.buildFrameSignature = "implemented";
    }
  }catch(_e){ /* ignore */ }

  // DevTools helpers (safe)
  try{
    window.__warcutDebug = window.__warcutDebug || {};
    window.__warcutDebug.buildFrameSignature = buildFrameSignature;
    window.__warcutDebug.buildDirtyFrameRanges = buildDirtyFrameRanges;
    window.__warcutDebug.dirty = window.__warcutPhaseB?.dirty || __B_dirty;
  }catch(_e){ /* ignore */ }

  // Stage 1: ONE true raster entry point
  function renderOverlayFrame({ t=0, overlays=[], targetW=BASE_W, targetH=BASE_H, safeAreaPreset="none", bg=null } = {}){
    const lb = __B_letterbox(targetW, targetH);
    const sa = __B_safeAreaRect(lb.contentW, lb.contentH, safeAreaPreset);

    const canvas = document.createElement("canvas");
    canvas.width = lb.targetW;
    canvas.height = lb.targetH;
    const ctx = canvas.getContext("2d");
    if (!ctx) return canvas;

    // bg can be "transparent" (default) or a color string
    if (bg){
      ctx.save();
      ctx.fillStyle = String(bg);
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.restore();
    } else {
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }

    const active = __B_getRenderableOverlaysAtTime(Number(t)||0, overlays);

    // Draw overlays into the 16:9 content rect; safe-area is an inset guide (doesn't change overlay math yet)
    ctx.save();
    ctx.translate(lb.offX, lb.offY);

    // Optional: visualize safe area (debug) if preset isn't none and bg is set
    // (kept off by default; enable via DevTools by setting __warcutDebug.showSafeArea=true)
    try{
      if (window.__warcutDebug?.showSafeArea && safeAreaPreset !== "none"){
        ctx.save();
        ctx.strokeStyle = "rgba(56,189,248,0.55)";
        ctx.lineWidth = Math.max(1, Math.round(2 * lb.s));
        ctx.strokeRect(sa.x, sa.y, sa.w, sa.h);
        ctx.restore();
      }
    }catch(_e){}

    for (const o of active){
      const ot = String(o?.type || "");
      let drawFn = null;
      let item = null;

      if (ot === "lower_third"){
        // Bridge schema -> raster item (drawLowerThird expects legacy x/y percent + strings)
        item = {
          xPct: o?.transform?.xPct,
          yPct: o?.transform?.yPct,
          scale: o?.transform?.scale,
          preset: o?.style?.preset,
          stylePreset: o?.style?.preset,
          kicker: o?.style?.kicker,
          title: o?.style?.title,
          subtitle: o?.style?.subtitle
        };
        drawFn = (ctx2, W2, H2) => __warcutRaster.drawLowerThird(ctx2, item, W2, H2);
      } else if (ot === "image"){
        const url = String(o?.asset?.url || o?.assetUrl || o?.style?.imageUrl || o?.imageUrl || "");
        const img = __B_getResolvedImage(url);
        if (!img) continue;

        item = {
          xPct: o?.transform?.xPct,
          yPct: o?.transform?.yPct,
          scale: o?.transform?.scale,
          opacity: (o?.asset?.opacity ?? o?.opacity ?? 1),
          fit: (o?.asset?.fit ?? o?.fit ?? "contain"),
          img,
          maxWPct: 35,
          maxHPct: 35
        };
        drawFn = (ctx2, W2, H2) => __warcutRaster.drawImageOverlay(ctx2, item, W2, H2);
      } else {
        continue;
      }

      const staticOk = __B_isStaticAtTime(o, t);
      if (staticOk){
        const k = `${o.id}:${__B_hashOverlayForCache(o)}:${lb.contentW}x${lb.contentH}`;
        const cached = __B_cacheGet(k);
        if (cached){
          ctx.drawImage(cached, 0, 0);
          continue;
        }

        const oc = document.createElement("canvas");
        oc.width = lb.contentW;
        oc.height = lb.contentH;
        const octx = oc.getContext("2d");
        octx.clearRect(0,0,oc.width,oc.height);
        drawFn(octx, oc.width, oc.height);
        __B_cacheSet(k, oc);
        ctx.drawImage(oc, 0, 0);
      } else {
        drawFn(ctx, lb.contentW, lb.contentH);
      }
    }

    ctx.restore();
    return canvas;
  }

  // Stage 4: schedule builder (dirty frames)
  function buildOverlayRenderScheduleV2({ overlays=null, fps=30, duration=0, targetW=BASE_W, targetH=BASE_H, useDirty=true, tracker=null } = {}){
    // Phase B ‚Äî Stage 4 / Stack 3
    // Build a recomposition schedule WITHOUT rendering.
    // Backward-compatible: assumes timeline starts at t=0 (start offsets not supported yet).
    fps = Math.max(1, Number(fps) || 30);
    duration = Math.max(0, Number(duration) || 0);
    targetW = Math.max(1, Number(targetW) || BASE_W);
    targetH = Math.max(1, Number(targetH) || BASE_H);

    const ovs = overlays || (window.__warcutDebug?.project?.overlays || window.__warcutDebug?.overlays || []);
    const frames = [];
    const total = Math.max(0, Math.ceil(duration * fps));
    let prevSig = null;

    // Optional explicit dirty ranges (from Stack 2 tracker). Kept conservative to avoid destabilization.
    let dirtyRanges = [];
    if (useDirty){
      try{
        const tr = tracker || window.__warcutPhaseB?.dirty || __B_dirty || null;
        const dr = (typeof buildDirtyFrameRanges === "function") ? buildDirtyFrameRanges({ overlays: ovs, fps, duration, tracker: tr }) : null;
        dirtyRanges = dr?.ranges || [];
      }catch(_e){ dirtyRanges = []; }
    }

    // Pointer walk through merged ranges
    let rIdx = 0;
    function __isExplicitDirty(i){
      while (rIdx < dirtyRanges.length && i > dirtyRanges[rIdx].i1) rIdx++;
      if (rIdx < dirtyRanges.length){
        const r = dirtyRanges[rIdx];
        return (i >= r.i0 && i <= r.i1);
      }
      return false;
    }

    for (let i=0;i<total;i++){
      const t = i / fps;

      // Signature uses Stack 2 builder (which uses Stack 1 classifier internally)
      const s = (typeof buildFrameSignature === "function")
        ? buildFrameSignature({ t, overlays: ovs, targetW, targetH })
        : { sig: "__DYNAMIC__", anyDynamic: true, activeCount: 0 };

      const sig = String(s?.sig ?? "__DYNAMIC__");
      const anyDynamic = !!s?.anyDynamic || (sig === "__DYNAMIC__");
      const count = Number.isFinite(+s?.activeCount) ? +s.activeCount : (Number.isFinite(+s?.count) ? +s.count : 0);

      const explicitDirty = __isExplicitDirty(i);

      // Core schedule rule:
      // - If any overlay is dynamic at t, treat frame as dirty (must render)
      // - Else if signature changed vs previous, dirty
      // - Else if explicitly marked dirty by edits, dirty
      const dirty = anyDynamic || explicitDirty || (sig !== prevSig);

      frames.push({
        i, t,
        dirty,
        anyDynamic,
        count,
        sig,
        explicitDirty
      });

      prevSig = sig;
    }

    return { totalFrames: total, frames, dirtyRanges };
  }

  // Backward-compatible wrapper: old signature buildOverlayRenderSchedule(overlays, fps, duration) -> frames[]
  function buildOverlayRenderSchedule(overlays, fps, duration, opts){
    // Allow new call style: buildOverlayRenderSchedule({overlays,fps,duration,...})
    if (overlays && typeof overlays === "object" && !Array.isArray(overlays) && arguments.length === 1){
      const out = buildOverlayRenderScheduleV2(overlays);
      return out.frames;
    }
    const out = buildOverlayRenderScheduleV2({ overlays, fps, duration, ...(opts||{}) });
    return out.frames;
  }

  // Stage 5: PNG frame rasterization harness
  async function* rasterizeOverlaysToPngFrames({ fps=30, start=0, end=0, targetW=BASE_W, targetH=BASE_H, safeAreaPreset="none", bg=null, overlays=null } = {}){
    fps = Math.max(1, Number(fps)||30);
    start = Math.max(0, Number(start)||0);
    end = Math.max(start, Number(end)||0);

    const ovs = overlays || (window.__warcutDebug?.project?.overlays || window.__warcutDebug?.overlays || []);
    await ensureOverlayAssetsReady(ovs);

    const total = Math.max(0, Math.ceil((end - start) * fps));
    for (let i=0;i<=total;i++){
      const t = start + (i / fps);
      const c = renderOverlayFrame({ t, overlays: ovs, targetW, targetH, safeAreaPreset, bg });
      const blob = await new Promise((resolve) => c.toBlob(resolve, "image/png"));
      yield { i, t, blob };
    }
  }

  // ==========================================================
  // Phase B ‚Äî Stage 5 / Stack 4: PNG Harness (Schedule-aware, reuse non-dirty)
  // Goal:
  //   - Produce PNG frames that match preview pixels
  //   - Reuse previous frame's PNG when schedule marks a frame "not dirty"
  //   - Keep behavior stable (fallback to legacy render-per-frame when needed)
  //
  // Notes:
  //   - This does NOT touch FFmpeg encoding; it only produces PNG blobs.
  //   - Uses Stage 4 Stack 3 schedule if available and start==0.
  // ==========================================================

  const rasterizeOverlaysToPngFramesLegacy = rasterizeOverlaysToPngFrames;

  async function __B_canvasToPngBlob(canvasOrOffscreen){
    if (!canvasOrOffscreen) return new Blob([], { type: "image/png" });

    // OffscreenCanvas (workers or some browsers)
    if (typeof canvasOrOffscreen.convertToBlob === "function"){
      try{
        return await canvasOrOffscreen.convertToBlob({ type: "image/png" });
      }catch(_e){ /* fallthrough */ }
    }

    // HTMLCanvasElement
    if (typeof canvasOrOffscreen.toBlob === "function"){
      const blob = await new Promise((resolve) => {
        try{
          canvasOrOffscreen.toBlob((b) => resolve(b), "image/png");
        }catch(_e){
          resolve(null);
        }
      });
      if (blob) return blob;
    }

    // Last-resort fallback
    try{
      const dataUrl = canvasOrOffscreen.toDataURL("image/png");
      const res = await fetch(dataUrl);
      return await res.blob();
    }catch(_e){
      return new Blob([], { type: "image/png" });
    }
  }

  async function* rasterizeOverlaysToPngFramesV2({
    fps=30,
    start=0,
    end=0,
    targetW=BASE_W,
    targetH=BASE_H,
    safeAreaPreset="none",
    bg=null,
    overlays=null,
    useSchedule=true,
    useDirty=true,
    tracker=null
  } = {}){
    fps = Math.max(1, Number(fps)||30);
    start = Math.max(0, Number(start)||0);
    end = Math.max(start, Number(end)||0);

    const ovs = overlays || (window.__warcutDebug?.project?.overlays || window.__warcutDebug?.overlays || []);
    await ensureOverlayAssetsReady(ovs);

    const duration = Math.max(0, end - start);
    const total = Math.max(0, Math.ceil(duration * fps)); // inclusive loop uses <= total

    // Prefer schedule only when time origin matches schedule's assumption (t starts at 0)
    const canUseSchedule = !!useSchedule && (start === 0) && (typeof buildOverlayRenderScheduleV2 === "function");
    const dirtyTracker = tracker || window.__warcutPhaseB?.dirty || null;

    let schedule = null;
    if (canUseSchedule){
      try{
        // +1/fps aligns schedule length with inclusive end loop (i=0..total)
        schedule = buildOverlayRenderScheduleV2({
          overlays: ovs,
          fps,
          duration: duration + (1 / fps),
          targetW,
          targetH,
          useDirty,
          tracker: dirtyTracker
        });
      }catch(_e){
        schedule = null;
      }
    }

    let lastBlob = null;
    let prevSig = null;

    for (let i=0;i<=total;i++){
      const t = start + (i / fps);

      // Determine whether we must re-render this frame.
      let dirty = true;
      let explicitDirty = false;
      let anyDynamic = false;

      const f = schedule?.frames?.[i];
      if (f){
        dirty = !!f.dirty;
        explicitDirty = !!f.explicitDirty;
        anyDynamic = !!f.anyDynamic;
      }else if (typeof buildFrameSignature === "function"){
        // Fallback: compute dirty from signature directly at actual time t (supports start offsets)
        const s = buildFrameSignature({ t, overlays: ovs, targetW, targetH });
        const sig = String(s?.sig ?? "__DYNAMIC__");
        anyDynamic = !!s?.anyDynamic || (sig === "__DYNAMIC__");
        dirty = (i === 0) || anyDynamic || (sig !== prevSig);
        prevSig = sig;
      }

      if (!dirty && lastBlob){
        yield { i, t, blob: lastBlob, reused: true, dirty: false, explicitDirty, anyDynamic };
        continue;
      }

      const c = renderOverlayFrame({ t, overlays: ovs, targetW, targetH, safeAreaPreset, bg });
      lastBlob = await __B_canvasToPngBlob(c);

      yield { i, t, blob: lastBlob, reused: false, dirty: true, explicitDirty, anyDynamic };
    }
  }

  // Attach to DevTools debug surface
  try{
    window.__warcutDebug = window.__warcutDebug || {};
    window.__warcutDebug.BASE_W = BASE_W;
    window.__warcutDebug.BASE_H = BASE_H;
    window.__warcutDebug.mapBaseToTarget = mapBaseToTarget;
    window.__warcutDebug.scaleBaseToTarget = scaleBaseToTarget;
    window.__warcutDebug.renderOverlayFrame = renderOverlayFrame;
    window.__warcutDebug.ensureOverlayAssetsReady = ensureOverlayAssetsReady;
    window.__warcutDebug.getOverlayTimeClass = __B_getOverlayTimeClass;
    window.__warcutDebug.getActiveOverlaysAtTime = __B_getActiveOverlaysAtTime;
    window.__warcutDebug.buildOverlayRenderSchedule = buildOverlayRenderSchedule;
    window.__warcutDebug.buildOverlayRenderScheduleV2 = buildOverlayRenderScheduleV2;
    // Expose schedule builder to PhaseB namespace (Stack 3)
    try{
      window.__warcutPhaseB = window.__warcutPhaseB || {};
      window.__warcutPhaseB.buildOverlayRenderSchedule = buildOverlayRenderSchedule;
      window.__warcutPhaseB.buildOverlayRenderScheduleV2 = buildOverlayRenderScheduleV2;
      if (window.__warcutPhaseB.__placeholders){
        window.__warcutPhaseB.__placeholders.buildRenderSchedule = "implemented";
      }
    }catch(_e){ /* ignore */ }
    // Stage 5 / Stack 4: expose both legacy and schedule-aware generators
    window.__warcutDebug.rasterizeOverlaysToPngFramesLegacy = rasterizeOverlaysToPngFramesLegacy;
    window.__warcutDebug.rasterizeOverlaysToPngFramesV2 = rasterizeOverlaysToPngFramesV2;
    window.__warcutDebug.rasterizeOverlaysToPngFrames = rasterizeOverlaysToPngFramesV2;

    try{
      window.__warcutPhaseB = window.__warcutPhaseB || {};
      window.__warcutPhaseB.rasterizeOverlaysToPngFramesLegacy = rasterizeOverlaysToPngFramesLegacy;
      window.__warcutPhaseB.rasterizeOverlaysToPngFramesV2 = rasterizeOverlaysToPngFramesV2;
      if (window.__warcutPhaseB.__placeholders){
        window.__warcutPhaseB.__placeholders.rasterizeToPngFrames = "implemented";
      }
    }catch(_e){ /* ignore */ }

    window.__warcutDebug.project = window.__warcutDebug.project || {};
    try{
      Object.defineProperties(window.__warcutDebug.project, {
        overlays:  { get: () => window.__warcutDebug.overlays },
        duration:  { get: () => {
          try{
            const cs = window.__warcutDebug.clips || [];
            return cs.reduce((mx,c) => Math.max(mx, (Number(c?.start)||0) + (Number(c?.dur)||0)), 0);
          }catch(_e){ return 0; }
        }},
        fps:       { get: () => {
          try{ const el = document.getElementById('fpsSelect'); return Number(el?.value)||30; }catch(_e){ return 30; }
        }}
      });
    }catch(_e){ /* ignore */ }
  }catch(_e){ /* ignore */ }

  async function transcodeToMp4(fileOrBlob, exportCtx, onLog){
    const ffmpeg = await __ensureFFmpeg(onLog);

    const safeNum = (v, d=0) => (Number.isFinite(+v) ? +v : d);
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    const inputExt = (() => {
      const t = (fileOrBlob && fileOrBlob.type) ? String(fileOrBlob.type) : "";
      if (t.includes("mp4")) return "mp4";
      if (t.includes("webm")) return "webm";
      if (t.includes("ogg")) return "ogg";
      return "bin";
    })();

    const inputName = `input.${inputExt}`;
    const outputName = "output.mp4";

    // Best-effort cleanup from previous runs
    try { await ffmpeg.deleteFile(inputName); } catch(_) {}
    try { await ffmpeg.deleteFile(outputName); } catch(_) {}

    // ---- Build export context ----
    const srcIn = clamp(safeNum(exportCtx?.srcIn, 0), 0, 1e9);
    const dur = safeNum(exportCtx?.dur, 0);
    const timelineBase = safeNum(exportCtx?.timelineBase, 0);

    const srcW = safeNum(exportCtx?.w, 1920);
    const srcH = safeNum(exportCtx?.h, 1080);

    // Keep exports manageable for wasm (and match our overlay raster size)
    let outW = Math.min(1280, srcW);
    let outH = Math.round(srcH * (outW / srcW));
    if (outW % 2) outW -= 1;
    if (outH % 2) outH -= 1;
    outW = Math.max(2, outW); outH = Math.max(2, outH);

    const gfx = Array.isArray(exportCtx?.gfx) ? exportCtx.gfx : [];

    // ---- Rasterize lower thirds into full-frame transparent PNGs ----
    // Phase B / Stage 1: single rasterizer code-path (shared with Export Frame)
    async function __ltPngBytes(item, W, H){
      // Phase 4A+ hotfix: support IMAGE overlays in MP4 burn-in by rasterizing a full-frame RGBA PNG
      // (keep legacy lower-third raster path untouched for LOWER_THIRD clips).
      try{
        const o = overlayFromGfxClip(item);
        const ot = String(o?.type || "");
        if (ot === "image"){
          try{ await ensureOverlayAssetsReady([o]); }catch(_e){}
          const tt = Number(o?.timing?.start ?? item?.start ?? 0) + 1e-3;
          const canvas = renderOverlayFrame({ t: tt, overlays:[o], targetW: W, targetH: H, bg: null });
          const blob = await __B_canvasToPngBlob(canvas);
          return await __fetchFile(blob);
        }
      }catch(_e){ /* fallthrough */ }
      return __warcutRaster.lowerThirdToPngBytes(item, W, H);
    }


    // Write input
    await ffmpeg.writeFile(inputName, await __fetchFile(fileOrBlob));

    // Write overlay PNGs
    const overlayFiles = [];
    for (let i=0;i<gfx.length;i++){
      const g = gfx[i];
      const name = `lt_${String(i).padStart(2,"0")}.png`;
      try{ await ffmpeg.deleteFile(name); }catch(_){}
      const bytes = await __ltPngBytes(g, outW, outH);
      await ffmpeg.writeFile(name, bytes);
      overlayFiles.push(name);
    }

    // ---- Build ffmpeg args (inputs + filter graph) ----
    const argsBase = [];

    // Trim to the timeline-selected clip if provided
    if (srcIn > 0) argsBase.push("-ss", String(srcIn));
    if (dur > 0) argsBase.push("-t", String(dur));

    argsBase.push("-fflags", "+genpts");
    argsBase.push("-i", inputName);

    // Add overlay inputs (looped)
    for (const f of overlayFiles){
      argsBase.push("-loop", "1", "-framerate", "30", "-i", f);
    }

    // Filter complex: scale base to outW/outH then overlay full-frame PNGs with enable between.
    const fc = [];
    fc.push(`[0:v]fps=30,scale=${outW}:${outH}:flags=bicubic,format=rgba,setpts=PTS-STARTPTS[base0]`);
    let last = "[base0]";
    const fadeD = 0.20;

    for (let i=0;i<gfx.length;i++){
      const g = gfx[i];
      const st = clamp(safeNum(g.start, 0) - timelineBase, 0, 1e9);
      const et = clamp(st + clamp(safeNum(g.dur, 2), 0.05, 1e9), 0, 1e9);

      const inLabel = `[${i+1}:v]`;
      const ovLabel = `[ov${i}]`;
      const outLabel = `[v${i}]`;

      const outStart = Math.max(st, et - fadeD);

      // Keep overlay alpha smooth; if enable window is tiny, fades collapse gracefully.
      fc.push(`${inLabel}format=rgba,fade=t=in:st=${st}:d=${fadeD}:alpha=1,fade=t=out:st=${outStart}:d=${fadeD}:alpha=1${ovLabel}`);
      fc.push(`${last}${ovLabel}overlay=0:0:enable='between(t,${st},${et})'${outLabel}`);
      last = outLabel;
    }

    // Ensure final is a standard output pixel format for MP4 players
    fc.push(`${last}format=yuv420p[vout]`);

    const filterComplex = fc.join(";");

    // ---- Encode attempts (codec availability depends on ffmpeg-core build) ----
    const encodeAttempts = [
      // Best: H.264 + AAC
      ["-filter_complex", filterComplex, "-map", "[vout]", "-map", "0:a?",
       "-c:v", "libx264", "-preset", "veryfast", "-crf", "28", "-pix_fmt", "yuv420p",
       "-c:a", "aac", "-b:a", "160k", "-movflags", "+faststart", "-shortest", outputName],

      // H.264 + MP3 fallback if AAC missing
      ["-filter_complex", filterComplex, "-map", "[vout]", "-map", "0:a?",
       "-c:v", "libx264", "-preset", "veryfast", "-crf", "28", "-pix_fmt", "yuv420p",
       "-c:a", "libmp3lame", "-b:a", "160k", "-movflags", "+faststart", "-shortest", outputName],

      // MPEG4 + AAC
      ["-filter_complex", filterComplex, "-map", "[vout]", "-map", "0:a?",
       "-c:v", "mpeg4", "-q:v", "5", "-pix_fmt", "yuv420p",
       "-c:a", "aac", "-b:a", "160k", "-movflags", "+faststart", "-shortest", outputName],

      // MPEG4 + MP3
      ["-filter_complex", filterComplex, "-map", "[vout]", "-map", "0:a?",
       "-c:v", "mpeg4", "-q:v", "5", "-pix_fmt", "yuv420p",
       "-c:a", "libmp3lame", "-b:a", "160k", "-movflags", "+faststart", "-shortest", outputName],
    ];

    let lastErr = null;
    for (const enc of encodeAttempts){
      try{
        await ffmpeg.exec([...argsBase, ...enc]);
        lastErr = null;
        break;
      }catch(e){
        lastErr = e;
      }
    }
    if (lastErr) throw lastErr;

    const data = await ffmpeg.readFile(outputName);
    return new Blob([data.buffer], { type: "video/mp4" });
  }


(() => {
  /* ===========================================
     Warcut Studio (Mockup v0A)
     - Import MP4/audio/images into Media Bin
     - Add items to timeline tracks (V1, GFX, A1)
     - Preview playback with a playhead + clip switching
     - Lower thirds rendered as HTML overlays
     - WebAudio mixing for imported audio files
     =========================================== */

  const $ = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

  // UI refs
  const importBtn = $("#importBtn");
  const fileInput = $("#fileInput");
  const binList = $("#binList");
  const binCount = $("#binCount");
  const addToTimelineBtn = $("#addToTimelineBtn");
  const removeMediaBtn = $("#removeMediaBtn");

  const projectName = $("#projectName");
  const projectNameInput = $("#projectNameInput");
  const fpsSelect = $("#fpsSelect");

  const codecText = $("#codecText");
  const codecChip = $("#codecChip");
  const statusHint = $("#statusHint");
  const masterMuteBtn = $("#masterMuteBtn");

  // Help modal refs
  const helpMenuBtn = $("#helpMenuBtn");
  const helpModalBackdrop = $("#helpModalBackdrop");
  const helpModalClose = $("#helpModalClose");
  const helpModalGotIt = $("#helpModalGotIt");
  // Help guide tabs
  const __helpNavBtns = Array.from(document.querySelectorAll("#helpModalBackdrop .help-navbtn"));
  const __helpSections = Array.from(document.querySelectorAll("#helpModalBackdrop .help-section"));
  const __helpMain = document.querySelector("#helpModalBackdrop .help-main");
  const __helpTitles = {
    "getting-started": "Warcut Studio ¬∑ Quick Guide",
    "import": "Help ¬∑ Importing Media",
    "timeline": "Help ¬∑ Timeline Editing",
    "graphics": "Help ¬∑ Graphics & Overlays",
    "viewport": "Help ¬∑ Viewport Controls",
    "export": "Help ¬∑ Exporting & Probing",
    "quirks": "Help ¬∑ Known Quirks",
    "roadmap": "Help ¬∑ What‚Äôs Next",
  };

  function __helpSetTab(tab){
    const t = String(tab || "getting-started");
    __helpNavBtns.forEach(b => b.classList.toggle("active", b.dataset.helpTab === t));
    __helpSections.forEach(s => s.classList.toggle("active", s.dataset.helpSection === t));
    const titleEl = document.querySelector("#helpModalTitle");
    if (titleEl && __helpTitles[t]) titleEl.textContent = __helpTitles[t];
    if (__helpMain) __helpMain.scrollTop = 0;
  }

  __helpNavBtns.forEach(b => {
    b.addEventListener("click", (e) => {
      e.preventDefault();
      __helpSetTab(b.dataset.helpTab);
    });
  });


  function __helpOpen(){
    if (!helpModalBackdrop) return;
    helpModalBackdrop.classList.add("show");
    helpModalBackdrop.setAttribute("aria-hidden","false");
    document.body.classList.add("modal-open");
    try{ __helpSetTab("getting-started"); }catch(_e){}
  }
  function __helpClose(){
    if (!helpModalBackdrop) return;
    helpModalBackdrop.classList.remove("show");
    helpModalBackdrop.setAttribute("aria-hidden","true");
    document.body.classList.remove("modal-open");
  }

  if (helpMenuBtn){
    helpMenuBtn.addEventListener("click", (e) => { e.preventDefault(); __helpOpen(); });
  }
  if (helpModalClose){
    helpModalClose.addEventListener("click", (e) => { e.preventDefault(); __helpClose(); });
  }
  if (helpModalGotIt){
    helpModalGotIt.addEventListener("click", (e) => { e.preventDefault(); __helpClose(); });
  }
  if (helpModalBackdrop){
    helpModalBackdrop.addEventListener("mousedown", (e) => {
      // click outside modal closes
      if (e.target === helpModalBackdrop) __helpClose();
    });
  }
  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && helpModalBackdrop && helpModalBackdrop.classList.contains("show")){
      __helpClose();
    }
  });

  const previewVideo = $("#previewVideo");
  const overlayLayer = $("#overlayLayer");
  const bgLayer = $("#bgLayer");
  const safeGuide = $("#safeGuide");
  
const previewShell = overlayLayer.closest(".preview-shell");

// Phase 2.4 ‚Äî Viewport Zoom/Pan (Preview Workspace)
// Ctrl + click-drag: zoom (drag down = zoom out, drag up = zoom in)
// Space + click-drag: pan (only affects the viewport view, never the exported output)
let __vpScale = 1;
let __vpPanX = 0;
let __vpPanY = 0;
let __vpMode = null; // "zoom" | "pan"
let __vpStartY = 0, __vpStartX = 0, __vpStartScale = 1, __vpStartPanX = 0, __vpStartPanY = 0;

function __vpClamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
function __vpApply(){
  if (!previewShell) return;
  previewShell.style.setProperty("--vpScale", String(__vpScale));
  previewShell.style.setProperty("--vpPanX", __vpPanX + "px");
  previewShell.style.setProperty("--vpPanY", __vpPanY + "px");
  // Apply inline transform too (most reliable across browsers)
  try{ previewShell.style.transform = `translate(${__vpPanX}px, ${__vpPanY}px) scale(${__vpScale})`; }catch(_e){}

}

// Avoid hijacking when typing in inputs.
function __vpIsTypingTarget(el){
  if (!el) return false;
  const t = (el.tagName||"").toLowerCase();
  return t === "input" || t === "textarea" || el.isContentEditable;
}

previewShell.addEventListener("pointerdown", (e) => {
  // Ctrl+drag zoom (do not start overlay drags while Ctrl is held)
  if (e.ctrlKey && !__vpIsTypingTarget(e.target)){
    __vpMode = "zoom";
    __vpStartY = e.clientY;
    __vpStartScale = __vpScale;
    try { previewShell.setPointerCapture(e.pointerId); } catch(_){}
    e.preventDefault();
    e.stopPropagation();
    return;
  }

  // Alt+drag pan (camera move) ‚Äî Space remains Play/Pause, do not bind Space for pan.
  if (e.altKey && !__vpIsTypingTarget(e.target)){
    __vpMode = "pan";
    __vpStartX = e.clientX;
    __vpStartY = e.clientY;
    __vpStartPanX = __vpPanX;
    __vpStartPanY = __vpPanY;
    try { previewShell.setPointerCapture(e.pointerId); } catch(_){}
    e.preventDefault();
    e.stopPropagation();
    return;
  }
}, true);

previewShell.addEventListener("pointermove", (e) => {
  if (!__vpMode) return;

  if (__vpMode === "zoom"){
    const dy = e.clientY - __vpStartY;
    // exponential zoom feels stable across long drags
    const next = __vpStartScale * Math.exp(-dy * 0.005);
    __vpScale = __vpClamp(next, 0.25, 3.5);
    __vpApply();
    e.preventDefault();
    return;
  }

  if (__vpMode === "pan"){
    __vpPanX = __vpStartPanX + (e.clientX - __vpStartX);
    __vpPanY = __vpStartPanY + (e.clientY - __vpStartY);
    __vpApply();
    e.preventDefault();
    return;
  }
}, {passive:false});

function __vpEnd(e){
  if (!__vpMode) return;
  __vpMode = null;
  try { previewShell.releasePointerCapture(e.pointerId); } catch(_){}
}
previewShell.addEventListener("pointerup", __vpEnd);
previewShell.addEventListener("pointercancel", __vpEnd);

// Double-click to reset view.
previewShell.addEventListener("dblclick", (e) => {
  if (__vpIsTypingTarget(e.target)) return;
  __vpScale = 1; __vpPanX = 0; __vpPanY = 0;
  __vpApply();
});

__vpApply();


// Phase A ‚Äî Stage 5.1 (hotfix): preview drag-to-position for GFX overlays (lower thirds)
let __overlayDragActive = false;
const __overlayDrag = {
  active:false,
  clip:null,
  el:null,
  container:null,
  startClientX:0,
  startClientY:0,
  startXPct:0,
  startYPct:0,
  shellRect:null,
  moved:false
};

function __beginOverlayDrag(e, el, clip){
  if (!clip || clip.kind !== "gfx") return;

  // Left mouse OR primary touch/pen
  if (e.button !== undefined && e.button !== 0) return;

  e.preventDefault();
  e.stopPropagation();

  // Pause playback so tick-based rerenders don't fight the drag.
  try{ if (isPlaying) pause(); }catch(_e){}

  // Click-select the overlay (mirrors timeline selection behavior).
  try{ selectClip(clip.id); }catch(_e){}

  __overlayDragActive = true;
  __overlayDrag.active = true;
  __overlayDrag.clip = clip;
  __overlayDrag.el = el;
  __overlayDrag.shellRect = (previewShell ? previewShell.getBoundingClientRect() : null);
  __overlayDrag.startClientX = e.clientX;
  __overlayDrag.startClientY = e.clientY;
  __overlayDrag.startXPct = (clip.x ?? 4.5);
  __overlayDrag.startYPct = (clip.y ?? 7);
  __overlayDrag.moved = false;
  __overlayDrag.pointerId = (e.pointerId != null ? e.pointerId : null);

  // Mode: move (default) or scale (when grabbing the corner handle)
  try{
    __overlayDrag.mode = (e.target && ((e.target.dataset && e.target.dataset.ovhandle==="scale") || (e.target.closest && e.target.closest(".ov-handle")))) ? "scale" : "move";
  }catch(_e){ __overlayDrag.mode = "move"; }
  __overlayDrag.startScale = (clip.scale ?? 1);
  try{
    const tr = (el && el.style ? (el.style.transform || "") : "");
    const mm = /translateY\(([-\d.]+)px\)/.exec(tr);
    __overlayDrag.startTyPx = mm ? parseFloat(mm[1]) : 0;
  }catch(_e){ __overlayDrag.startTyPx = 0; }

  try{
    const cont = (el && el.closest) ? (el.closest(".overlay-layer, .bg-layer") || overlayLayer) : overlayLayer;
    __overlayDrag.container = cont;
    if (cont) cont.classList.add("interactive");
  }catch(_e){}
  try{ el.classList.add("dragging"); }catch(_e){}

  // Capture pointer so we keep getting move events
  try{
    if (__overlayDrag.pointerId != null && el.setPointerCapture){
      el.setPointerCapture(__overlayDrag.pointerId);
    }
  }catch(_e){}

  // Prefer pointer events; fall back to mouse.
  if ("PointerEvent" in window){
    window.addEventListener("pointermove", __overlayDragMove, {passive:false});
    window.addEventListener("pointerup", __overlayDragEnd, {once:true, passive:false});
    window.addEventListener("pointercancel", __overlayDragEnd, {once:true, passive:false});
  } else {
    window.addEventListener("mousemove", __overlayDragMove, {passive:false});
    window.addEventListener("mouseup", __overlayDragEnd, {once:true});
  }
}

function __overlayDragMove(e){
  if (!__overlayDragActive || !__overlayDrag.active) return;
  if (__overlayDrag.pointerId != null && e.pointerId != null && e.pointerId !== __overlayDrag.pointerId) return;

  e.preventDefault();

  const clip = __overlayDrag.clip;
  const el = __overlayDrag.el;
  if (!clip || !el) return;

  const rect = __overlayDrag.shellRect || (previewShell ? previewShell.getBoundingClientRect() : null);
  if (!rect || !rect.width || !rect.height) return;

  const dx = e.clientX - __overlayDrag.startClientX;
  const dy = e.clientY - __overlayDrag.startClientY;

  if (!__overlayDrag.moved && (Math.abs(dx) + Math.abs(dy) > 2)){
    __overlayDrag.moved = true;
    try{ __pushUndo(__overlayDrag.mode==="scale" ? "Resize overlay" : "Move overlay"); }catch(_e){}
  }
  // Resize mode: adjust scale via horizontal drag on the corner handle
  if (((__overlayDrag.mode || "move") === "scale")){
    const frac = (dx / rect.width);
    const nextScale = clampNum(__overlayDrag.startScale * (1 + frac * 1.6), 0.2, 6, __overlayDrag.startScale);
    clip.scale = nextScale;
    try{
      if (clip.overlay && clip.overlay.transform){
        clip.overlay.transform.scale = nextScale;
      }
    }catch(_e){}

    // Live scale update
    const ty = Number.isFinite(__overlayDrag.startTyPx) ? __overlayDrag.startTyPx : 0;
    el.style.transformOrigin = "left bottom";
    el.style.transform = `translateY(${ty}px) scale(${nextScale})`;

    // Keep inspector fields in sync if this clip is selected.
    try{
      if (selectedClipId === clip.id){
        const scIn = $("#insScale");
        const scVal = $("#insScaleVal");
        if (scIn) scIn.value = String(nextScale);
        if (scVal) scVal.textContent = String(nextScale.toFixed(2));
      }
    }catch(_e){}
    return;
  }

  const dxPct = (dx / rect.width) * 100;
  const dyPct = (-dy / rect.height) * 100;

  const nextX = clampNum(__overlayDrag.startXPct + dxPct, -50, 150, __overlayDrag.startXPct);
  const nextY = clampNum(__overlayDrag.startYPct + dyPct, -50, 150, __overlayDrag.startYPct);

  clip.x = nextX;
  clip.y = nextY;

  // Keep nested schema aligned during drag so nothing "snaps back".
  try{
    if (clip.overlay && clip.overlay.transform){
      clip.overlay.transform.xPct = nextX;
      clip.overlay.transform.yPct = nextY;
    }
  }catch(_e){}

  // Live move (no full rerender while dragging)
  el.style.left = nextX + "%";
  el.style.bottom = nextY + "%";

  // Keep inspector fields in sync if this clip is selected.
  try{
    if (selectedClipId === clip.id){
      gfxX.value = String(nextX.toFixed(1));
      gfxY.value = String(nextY.toFixed(1));
    }
  }catch(_e){}
}

function __overlayDragEnd(e){
  // Remove whichever listener we attached.
  try{ window.removeEventListener("pointermove", __overlayDragMove); }catch(_e){}
  try{ window.removeEventListener("mousemove", __overlayDragMove); }catch(_e){}

  if (!__overlayDragActive) return;

  const clip = __overlayDrag.clip;
  const el = __overlayDrag.el;

  try{
    if (__overlayDrag.pointerId != null && el && el.releasePointerCapture){
      el.releasePointerCapture(__overlayDrag.pointerId);
    }
  }catch(_e){}

  try{ if (el) el.classList.remove("dragging"); }catch(_e){}

  __overlayDragActive = false;
  __overlayDrag.active = false;
  __overlayDrag.pointerId = null;
  __overlayDrag.container = null;

  // Sync overlay schema + commit once at the end.
  try{
    if (__overlayDrag.moved && clip && clip.kind === "gfx"){
      // Ensure nested schema matches the final flat fields
      applyOverlayToGfxClip(clip, overlayFromGfxClip(clip), {silent:true});
      try{ __normalizeOverlayOrdering(true); }catch(_e){ try{ __normalizeOverlayOrdering(); }catch(_e2){} }
      try{ __scheduleOverlayCommit("overlay-drag"); }catch(_e){}
    }
  }catch(_e){}

  try{ renderInspector(); }catch(_e){}
  try{ renderTimeline(); }catch(_e){}
  try{ renderOverlays(); }catch(_e){}
}

const toggleSafeBtn = $("#toggleSafeBtn");

  const playBtn = $("#playBtn");
  const stopBtn = $("#stopBtn");
  const stepBack = $("#stepBack");
  const stepFwd = $("#stepFwd");
  const timeReadout = $("#timeReadout");
  const playheadSecLabel = $("#playheadSec");
  const activeClipChip = $("#activeClipChip");

  const ruler = $("#ruler");
  const lanes = $("#lanes");
  const laneScroll = $("#laneScroll");
  const playheadEl = $("#playhead");
  const laneV1 = $("#laneV1");
  const laneGFX = $("#laneGFX");
  const laneA1 = $("#laneA1");

  const timelineResize = $("#timelineResize");
  const timelineEl = $("#timeline");

  const zoomScale = $("#zoomScale");
  const zoomScaleVal = $("#zoomScaleVal");

  const helpBtn = $("#helpBtn");
  const helpModal = $("#helpModal");
  const helpClose = $("#helpClose");
  const helpOk = $("#helpOk");

  const exportBtn = $("#exportBtn");
  const exportModal = $("#exportModal");
  const exportClose = $("#exportClose");
  const exportOk = $("#exportOk");
  const exportJsonBtn = $("#exportJsonBtn");
  const exportWebmBtn = $("#exportWebmBtn");
  const exportFrameBtn = $("#exportFrameBtn");
  const exportProbeBtn = $("#exportProbeBtn");
  const exportProbeStrip = $("#exportProbeStrip");
  const exportProbeStatus = $("#exportProbeStatus");
  const exportProbeClearBtn = $("#exportProbeClearBtn");
  const importProjectJsonBtn = $("#importProjectJsonBtn");
  const projectInput = $("#projectInput");

  const codecModal = $("#codecModal");
  const codecClose = $("#codecClose");
  const codecOk = $("#codecOk");
  const codecReport = $("#codecReport");


  const splitBtn = $("#splitBtn");
  const deleteBtn = $("#deleteBtn");
  const snapBtn = $("#snapBtn");
  const snapState = $("#snapState");
  const rippleBtn = $("#rippleBtn");
  const rippleState = $("#rippleState");
  const undoBtn = $("#undoBtn");
  const redoBtn = $("#redoBtn");

  const addLowerThirdBtn = $("#addLowerThirdBtn");

  // New Project (clears autosave + revokes local blob URLs)
  const newProjectBtn = $("#newProjectBtn");
  if (newProjectBtn){
    newProjectBtn.addEventListener("click", () => hardResetProject());
  }
  window.addEventListener("keydown", (e) => {
    try{
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && (e.key === "N" || e.key === "n")){
        e.preventDefault();
        hardResetProject();
      }
    }catch(_e){}
  });


  const v1Count = $("#v1Count");
  const gfxCount = $("#gfxCount");
  const a1Count = $("#a1Count");
  const timelineLenLabel = $("#timelineLen");

  // Inspector clip fields
  const clipNone = $("#clipNone");
  const clipFields = $("#clipFields");
  const clipStart = $("#clipStart");
  const clipDur = $("#clipDur");
  const clipIn = $("#clipIn");
  const clipOut = $("#clipOut");
  const applyClipBtn = $("#applyClipBtn");
  const muteClipBtn = $("#muteClipBtn");
  const muteClipState = $("#muteClipState");

  // Inspector gfx fields
  const gfxNone = $("#gfxNone");
  const gfxFields = $("#gfxFields");
  const gfxKicker = $("#gfxKicker");
  const gfxTitle = $("#gfxTitle");
  const gfxSub = $("#gfxSub");
  const gfxStart = $("#gfxStart");
  const gfxDur = $("#gfxDur");
  const gfxX = $("#gfxX");
  const gfxY = $("#gfxY");
  const gfxScale = $("#gfxScale");
  const gfxMotion = $("#gfxMotion");
  const applyGfxBtn = $("#applyGfxBtn");
  const previewGfxBtn = $("#previewGfxBtn");
  const previewGfxState = $("#previewGfxState");
  const gfxEnabledBtn = $("#gfxEnabledBtn");
  const gfxEnabledState = $("#gfxEnabledState");
  const gfxSoloBtn = $("#gfxSoloBtn");
  const gfxSoloState = $("#gfxSoloState");
  const gfxTextFields = $("#gfxTextFields");
  const gfxImageFields = $("#gfxImageFields");
  const gfxLayer = $("#gfxLayer");
  const gfxFit = $("#gfxFit");
  const gfxOpacity = $("#gfxOpacity");
  const gfxPresetsBlock = $("#gfxPresetsBlock");
  const presetNews = $("#presetNews");
  const presetCine = $("#presetCine");
  const presetMinimal = $("#presetMinimal");

  // Tabs
  $$(".tab").forEach(tab => {
    tab.addEventListener("click", () => {
      $$(".tab").forEach(t => t.classList.toggle("active", t === tab));
      const key = tab.dataset.tab;
      $("#pane-project").classList.toggle("active", key === "project");
      $("#pane-clip").classList.toggle("active", key === "clip");
      $("#pane-gfx").classList.toggle("active", key === "gfx");
    });
  });

  // Global state
  let media = []; // {id, kind, name, file, url, duration?, w?, h?, thumbUrl?}
  let selectedMediaId = null;

  // timeline clips: {id, track, mediaId?, kind:'video'|'audio'|'gfx', start, dur, in, out, title?, subtitle?, kicker?, stylePreset?, clipAudioMuted?}
  let clips = [];
  let selectedClipId = null;

  let snapOn = true;
  let rippleOn = false;

  // Undo/Redo (lightweight state snapshots)
  let undoStack = [];
  let redoStack = [];

  // playback
  let isPlaying = false;
  let playhead = 0; // seconds
  let raf = 0;
  let lastPerf = 0;

  // audio engine
  let audioCtx = null;
  let audioGain = null;
  let audioSources = []; // {clipId, srcNode, startedAtCtxTime, offsetSec}

  // clip audio behavior
  let useClipAudio = false; // selected clip toggle
  previewVideo.controls = false;
  previewVideo.muted = false; // default so imported clips can be heard (clip toggle still applies)
  updateMasterMuteBtn();
  masterMuteBtn?.addEventListener("click", () => {
    masterMuted = !masterMuted;
    updateMasterMuteBtn();
    // Apply immediately
    if (masterMuted){
      previewVideo.muted = true;
      if (audioGain) audioGain.gain.value = 0;
    } else {
      // restore routing
      try{ applyAudioMaster && applyAudioMaster(); }catch(_e){}
      if (audioGain) audioGain.gain.value = 0.9;
    }
  });

  // GFX preview
  let gfxPreviewOn = true;

  // Master mute (quick safety toggle)
  var masterMuted = false;

  const uid = () => Math.random().toString(36).slice(2, 10);

  // ----------------------------------------------------------
  // Debug hooks (module-safe)
  // This file uses <script type="module">, so variables like `clips`
  // aren't directly accessible from DevTools console.
  // These getters expose read-only access for inspection.
  // ----------------------------------------------------------
  window.__warcutDebug = window.__warcutDebug || {};
  try{
    Object.defineProperties(window.__warcutDebug, {
      media:       { get: () => media },
      clips:       { get: () => clips },
      gfxClips:    { get: () => clips.filter(c => c && c.kind === "gfx") },
      overlays:    { get: () => clips.filter(c => c && c.kind === "gfx").map(c => c.overlay).filter(Boolean) },
      firstOverlay:{ get: () => clips.find(c => c && c.kind === "gfx")?.overlay }
    });
  }catch(_e){ /* ignore if properties already defined */ }


  /* ==========================================================
     Phase A ‚Äî Overlay Core Schema & Serialization
     Stage 1: Overlay Object Contract (schema + normalizers)
     NOTE: This stage is intentionally export-agnostic.
  ========================================================== */

  const OVERLAY_SCHEMA_VERSION = 1;
  const OVERLAY_TYPES = Object.freeze({
    LOWER_THIRD: "lower_third",
    IMAGE: "image"
  });

  const __ovIsObj = (v) => !!v && typeof v === "object" && !Array.isArray(v);
  const __ovNum = (v, d=0) => (Number.isFinite(+v) ? +v : d);
  const __ovClamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

  function __overlayBase(id, type){
    const t = String(type || OVERLAY_TYPES.LOWER_THIRD);
    if (t === OVERLAY_TYPES.IMAGE){
      return {
        schemaVersion: OVERLAY_SCHEMA_VERSION,
        id: String(id || uid()),
        type: OVERLAY_TYPES.IMAGE,
        enabled: true,
        layer: "overlay",
        solo: false,
        zIndex: 5,
        timing: { start: 0, dur: 3 },
        transform: { xPct: 4.5, yPct: 7, scale: 1 },
        // Image-specific asset metadata (best-effort; object URLs are session-scoped)
        asset: { kind: "image", url: "", name: "", w: 0, h: 0, fit: "contain", opacity: 1 },
        // Keep style/motion present so legacy UI bindings don't break
        style: { preset: "image", kicker: "", title: "", subtitle: "" },
        motion: { preset: "fade" }
      };
    }

    return {
      schemaVersion: OVERLAY_SCHEMA_VERSION,
      id: String(id || uid()),
      type: OVERLAY_TYPES.LOWER_THIRD,
      enabled: true,
      layer: "overlay",
      solo: false,
      zIndex: 10,
      timing: { start: 0, dur: 3 },
      transform: { xPct: 4.5, yPct: 7, scale: 1 },
      style: {
        preset: "news",
        kicker: "WARCHIEF",
        title: "Lower Third Title",
        subtitle: "Subtitle / role / location"
      },
      motion: { preset: "fade" }
    };
  }

  // Ensures an overlay object matches the unified schema.
  // Accepts legacy flat fields too (start/dur/x/y/scale/title/subtitle/kicker/stylePreset/motion).
  function ensureOverlaySchema(input){
    const o = __ovIsObj(input) ? input : {};
    const wantType = String(o.type || OVERLAY_TYPES.LOWER_THIRD);
    const type = (wantType === OVERLAY_TYPES.LOWER_THIRD || wantType === OVERLAY_TYPES.IMAGE) ? wantType : OVERLAY_TYPES.LOWER_THIRD;
    const base = __overlayBase(o.id, type);

    const out = {
      schemaVersion: OVERLAY_SCHEMA_VERSION,
      id: String(o.id || base.id),
      type: type,
      enabled: (o.enabled === undefined) ? base.enabled : !!o.enabled,
      solo: !!o.solo,
      zIndex: Math.round(__ovNum(o.zIndex, base.zIndex)),
      layer: (function(){ const l = String(o.layer ?? base.layer ?? "overlay"); return (l==="bg"||l==="background") ? "bg" : "overlay"; })(),

      timing: {
        start: Math.max(0, __ovNum(o.timing?.start ?? o.start, base.timing.start)),
        dur: Math.max(0.01, __ovNum(o.timing?.dur ?? o.dur, base.timing.dur))
      },

      transform: {
        xPct: __ovClamp(__ovNum(o.transform?.xPct ?? o.xPct ?? o.x, base.transform.xPct), -50, 150),
        yPct: __ovClamp(__ovNum(o.transform?.yPct ?? o.yPct ?? o.y, base.transform.yPct), -50, 150),
        scale: __ovClamp(__ovNum(o.transform?.scale ?? o.scale, base.transform.scale), 0.25, 3)
      },

      style: {
        preset: String(o.style?.preset ?? o.preset ?? o.stylePreset ?? base.style.preset),
        kicker: String(o.style?.kicker ?? o.kicker ?? base.style.kicker),
        title: String(o.style?.title ?? o.title ?? base.style.title),
        subtitle: String(o.style?.subtitle ?? o.subtitle ?? base.style.subtitle)
      },

      // Image overlays carry an asset descriptor used by the Phase B rasterizer.
      asset: (type === OVERLAY_TYPES.IMAGE) ? {
        kind: "image",
        url: String(o.asset?.url ?? o.assetUrl ?? o.url ?? o.imageUrl ?? base.asset?.url ?? ""),
        name: String(o.asset?.name ?? o.assetName ?? base.asset?.name ?? ""),
        w: Math.round(__ovNum(o.asset?.w ?? o.w ?? base.asset?.w, 0)),
        h: Math.round(__ovNum(o.asset?.h ?? o.h ?? base.asset?.h, 0)),
        fit: String(o.asset?.fit ?? o.fit ?? base.asset?.fit ?? "contain"),
        opacity: __ovClamp(__ovNum(o.asset?.opacity ?? o.opacity ?? base.asset?.opacity, 1), 0, 1)
      } : undefined,

      motion: {
        preset: String(o.motion?.preset ?? o.motion ?? base.motion.preset)
      }
    };

    if (!Number.isFinite(out.zIndex)) out.zIndex = base.zIndex;
    out.zIndex = __ovClamp(out.zIndex, -9999, 9999);

    return out;
  }

  // Factory helper for creating a fully valid overlay.
  function DEFAULT_OVERLAY(partial = {}){
    const base = __overlayBase(partial?.id);
    const merged = Object.assign({}, base, partial || {});
    // Deep-merge the structured bits we care about:
    if (__ovIsObj(partial?.timing)) merged.timing = Object.assign({}, base.timing, partial.timing);
    if (__ovIsObj(partial?.transform)) merged.transform = Object.assign({}, base.transform, partial.transform);
    if (__ovIsObj(partial?.style)) merged.style = Object.assign({}, base.style, partial.style);
    if (__ovIsObj(partial?.motion)) merged.motion = Object.assign({}, base.motion, partial.motion);
    return ensureOverlaySchema(merged);
  }

  function normalizeOverlayList(overlays){
    const arr = Array.isArray(overlays) ? overlays : [];
    const out = [];
    for (const item of arr){
      if (!item) continue;
      try{
        out.push(ensureOverlaySchema(item));
      }catch(_e){
        // swallow invalid overlay entries (Stage 1 rule: safe filtering)
      }
    }
    return out;
  }

  
  /* ==========================================================
     Phase A ‚Äî Overlay Core Schema & Serialization
     Stage 2: Deterministic Ordering + Z-Index Normalization
     NOTE: This stage is still export-agnostic.
  ========================================================== */

  function __overlayCompare(a, b){
    const ao = ensureOverlaySchema(a || {});
    const bo = ensureOverlaySchema(b || {});
    const az = __ovNum(ao.zIndex, 0);
    const bz = __ovNum(bo.zIndex, 0);
    if (az !== bz) return az - bz;

    const as = __ovNum(ao.timing?.start, 0);
    const bs = __ovNum(bo.timing?.start, 0);
    if (as !== bs) return as - bs;

    const aid = String(ao.id || "");
    const bid = String(bo.id || "");
    if (aid < bid) return -1;
    if (aid > bid) return 1;
    return 0;
  }

  // Normalizes overlay ordering and assigns deterministic zIndex steps (10,20,30,...)
  // The underlying clips[] order is NOT changed; zIndex becomes the single source of truth.
  function __normalizeOverlayOrdering(silent=false){
    const gfx = clips.filter(c => c && c.kind === "gfx");
    // Ensure every gfx clip has an overlay object first
    for (const c of gfx){
      try{ applyOverlayToGfxClip(c, overlayFromGfxClip(c), {silent}); }catch(_e){}
    }

    const ordered = gfx.slice().sort((a,b) => __overlayCompare(a.overlay, b.overlay));

    for (let i = 0; i < ordered.length; i++){
      const c = ordered[i];
      const desired = (i + 1) * 10;
      if (!c || !c.overlay) continue;
      if (c.overlay.zIndex !== desired){
        const next = ensureOverlaySchema(Object.assign({}, c.overlay, { zIndex: desired }));
        applyOverlayToGfxClip(c, next, {silent});
      }
    }
    return ordered;
  }

  // DevTools helper hooks (read-only + safe)
  try{
    if (window.__warcutDebug){
      window.__warcutDebug.normalizeOverlayOrdering = () => {
        __normalizeOverlayOrdering();
        return window.__warcutDebug.overlays;
      };
      window.__warcutDebug.getOrderedOverlays = () => {
        const ordered = clips
          .filter(c => c && c.kind === "gfx" && c.overlay)
          .slice()
          .sort((a,b) => __overlayCompare(a.overlay, b.overlay));
        return ordered.map(c => c.overlay);
      };
    }
  }catch(_e){ /* ignore */ }



  /* ==========================================================
     Phase A ‚Äî Overlay Core Schema & Serialization
     Stage 3: Runtime Visibility Rules (Enabled + Solo)
     NOTE: Preview-only. Export paths remain unchanged in Stage 3.
  ========================================================== */

  // Returns a list of overlay objects that should render, applying:
  // - enabled=false => hidden
  // - if any enabled overlays are solo=true => only those render
  function getRenderableOverlays(overlays){
    const normalized = normalizeOverlayList(overlays);
    const enabled = normalized.filter(o => !!o.enabled);
    const solo = enabled.filter(o => !!o.solo);
    return solo.length ? solo : enabled;
  }

  // Convenience: same visibility rules but operating on the app's gfx clips.
  function getRenderableGfxClips(gfxClips){
    const list = Array.isArray(gfxClips) ? gfxClips : [];
    const pairs = [];
    for (const c of list){
      if (!c) continue;
      const ov = (c.overlay ? ensureOverlaySchema(c.overlay) : overlayFromGfxClip(c));
      // keep legacy + canonical in sync (Stage 1 contract)
      applyOverlayToGfxClip(c, ov);
      pairs.push({ clip: c, overlay: ov });
    }
    const renderOvs = getRenderableOverlays(pairs.map(p => p.overlay));
    const allow = new Set(renderOvs.map(o => o.id));
    return pairs.filter(p => allow.has(p.overlay.id)).map(p => p.clip);
  }

  // DevTools helper hooks (safe + preview-only)
  try{
    if (window.__warcutDebug){
      window.__warcutDebug.getRenderableOverlaysAtTime = (t = playhead) => {
        const active = clips.filter(c => c && c.kind === "gfx" && t >= c.start && t <= (c.start + c.dur));
        return getRenderableGfxClips(active).map(c => c.overlay).filter(Boolean);
      };

      window.__warcutDebug.setOverlayEnabled = (id, enabled) => {
        const c = clips.find(x => x && x.kind === "gfx" && ((x.overlay?.id || x.id) === id));
        if (!c) return false;
        applyOverlayToGfxClip(c, ensureOverlaySchema(Object.assign({}, c.overlay || overlayFromGfxClip(c), { enabled: !!enabled })));
        try{ renderTimeline(); }catch(_e){}
        try{ renderOverlays(); }catch(_e){}
        try{ renderInspector(); }catch(_e){}
        return true;
      };

      window.__warcutDebug.setOverlaySolo = (id, solo) => {
        const c = clips.find(x => x && x.kind === "gfx" && ((x.overlay?.id || x.id) === id));
        if (!c) return false;
        const patch = { solo: !!solo };
        if (solo) patch.enabled = true; // solo implies visible
        applyOverlayToGfxClip(c, ensureOverlaySchema(Object.assign({}, c.overlay || overlayFromGfxClip(c), patch)));
        try{ renderTimeline(); }catch(_e){}
        try{ renderOverlays(); }catch(_e){}
        try{ renderInspector(); }catch(_e){}
        return true;
      };
    }
  }catch(_e){ /* ignore */ }

// --- Bridge helpers (current app uses GFX clips; Stage 1 keeps UI/preview stable) ---

  function overlayFromGfxClip(c){
    // Merge legacy flat clip fields on top of any existing c.overlay,
    // so the latest edits (Inspector/drag) always win.
    const existing = (__ovIsObj(c?.overlay) ? c.overlay : {});

    // Infer type (legacy UI only knows "gfx"; this keeps new image overlays compatible)
    const inferred = String(existing.type || c?.gfxType || ((c?.assetUrl || c?.imageUrl) ? OVERLAY_TYPES.IMAGE : OVERLAY_TYPES.LOWER_THIRD));
    const type = (inferred === OVERLAY_TYPES.IMAGE || inferred === OVERLAY_TYPES.LOWER_THIRD) ? inferred : OVERLAY_TYPES.LOWER_THIRD;

    // Best-effort image asset lookup (bin media) when present
    let assetUrl = existing?.asset?.url || c?.assetUrl || c?.assetUrl;
    let assetName = existing?.asset?.name || c?.assetName;
    let assetW = existing?.asset?.w || c?.assetW;
    let assetH = existing?.asset?.h || c?.assetH;
    if (type === OVERLAY_TYPES.IMAGE){
      try{
        const m = (c?.mediaId ? media.find(x => x.id === c.mediaId) : null);
        if (m && m.kind === "image"){
          assetUrl = assetUrl || m.url;
          assetName = assetName || m.name;
          assetW = assetW || m.w;
          assetH = assetH || m.h;
        }
      }catch(_e){}
    }

    const patch = {
      id: c?.id ?? existing.id,
      type,

      // Future flags (Stage 3 uses these; Stage 1 only stores/normalizes)
      enabled: (c?.enabled === undefined) ? existing.enabled : c.enabled,
      solo: (c?.solo === undefined) ? existing.solo : c.solo,
      zIndex: (c?.zIndex === undefined) ? existing.zIndex : c.zIndex,
      layer: (c?.layer === undefined) ? existing.layer : c.layer,

      // IMPORTANT: force timing to follow the clip start/dur even if an older overlay.timing exists.
      timing: Object.assign({}, (existing.timing || {}), { start: c?.start, dur: c?.dur }),

      // Legacy compatibility fields (accepted by ensureOverlaySchema)
      start: c?.start,
      dur: c?.dur,
      xPct: c?.x,
      yPct: c?.y,
      scale: c?.scale,
      stylePreset: c?.stylePreset,
      kicker: c?.kicker,
      title: c?.title,
      subtitle: c?.subtitle,
      motion: c?.motion
    };

    if (type === OVERLAY_TYPES.IMAGE){
      patch.asset = Object.assign({}, existing.asset || {}, {
        kind: "image",
        url: String(assetUrl || ""),
        name: String(assetName || ""),
        w: Math.round(__ovNum(assetW, 0)),
        h: Math.round(__ovNum(assetH, 0)),
        fit: String((c?.assetFit ?? existing?.asset?.fit ?? "contain")),
        opacity: __ovClamp(__ovNum((c?.assetOpacity ?? existing?.asset?.opacity ?? 1), 1), 0, 1)
      });
    }

    return ensureOverlaySchema(Object.assign({}, existing, patch));
  }

  function applyOverlayToGfxClip(c, overlay, opts){
    if (!c) return c;
    const o = ensureOverlaySchema(overlay);

    // Canonical nested store (Phase A foundation)
    c.overlay = o;

    // Mirror the currently-used flat fields so existing v0A logic stays unchanged.
    c.start = o.timing.start;
    c.dur = o.timing.dur;

    c.x = o.transform.xPct;
    c.y = o.transform.yPct;
    c.scale = o.transform.scale;

    c.stylePreset = o.style.preset;
    c.kicker = o.style.kicker;
    c.title = o.style.title;
    c.subtitle = o.style.subtitle;


    // Image overlays: mirror asset metadata for legacy UI/readouts
    if (String(o.type) === OVERLAY_TYPES.IMAGE){
      c.gfxType = "image";
      c.assetUrl = o.asset?.url || c.assetUrl || "";
      c.assetName = o.asset?.name || c.assetName || "";
      c.assetW = (o.asset?.w ?? c.assetW ?? 0);
      c.assetH = (o.asset?.h ?? c.assetH ?? 0);
    }
    c.motion = o.motion.preset;

    // Future fields (Phase A / Stage 3+)
    c.enabled = o.enabled;
    c.solo = o.solo;
    c.zIndex = o.zIndex;
    c.layer = o.layer;

    // Phase B / Stage 4 (Stack 2): mark dirty time ranges for export scheduling (safe)
    // (No effect unless Stage 4 scheduling APIs are used.)
    if (!(opts && opts.silent)){
      try{
        const dirty = window.__warcutPhaseB && window.__warcutPhaseB.dirty;
        if (dirty && typeof dirty.markOverlayChange === "function"){
          dirty.markOverlayChange(o, "overlay-edit");
        }
      }catch(_e){ /* ignore */ }
    }

    // Phase A / Stage 5: seal overlay pipeline (normalize + autosave) without thrashing
    if (!(opts && opts.silent)){
      try{ __scheduleOverlayCommit("applyOverlayToGfxClip"); }catch(_e){}
    }

    return c;
  }

  function __normalizeAllGfxClips(){
    for (const c of clips){
      if (c && c.kind === "gfx"){
        applyOverlayToGfxClip(c, overlayFromGfxClip(c), {silent:true});
      }
    }
  }
  /* ==========================================================
     Phase A ‚Äî Stage 5: Seal Overlay Core (Finalization)
     - Central commit pipeline (normalize ‚Üí validate ‚Üí autosave)
     - Safe autosave restore (only when project is empty)
     - Deterministic stringify with stable key ordering
     ========================================================== */

  const __AUTOSAVE_KEY = "warcut_autosave_payload_v1";
  const __AUTOSAVE_META_KEY = "warcut_autosave_meta_v1";

  let __overlayCommitPending = false;
  let __overlayCommitLocked = false;
  let __overlayCommitReason = "";

  function __scheduleOverlayCommit(reason){
    if (__overlayCommitLocked) return;
    __overlayCommitReason = String(reason || __overlayCommitReason || "overlay-change");
    if (__overlayCommitPending) return;
    __overlayCommitPending = true;
    queueMicrotask(() => {
      __overlayCommitPending = false;
      __commitOverlayCore(__overlayCommitReason);
      __overlayCommitReason = "";
    });
  }

  function __commitOverlayCore(reason){
    if (__overlayCommitLocked) return;
    __overlayCommitLocked = true;
    try{
      // Normalize ordering (z-index) for deterministic layering.
      try{ __normalizeOverlayOrdering(true); }catch(_e){
        // Fallback if older signature is present
        try{ __normalizeOverlayOrdering(); }catch(_e2){}
      }

      // Validate invariants (warnings only; no crashes).
      const report = __overlayHealthCheck();
      if (!report.ok){
        console.warn("[OverlayCore] Health check issues:", report.issues);
      } else {
        // lightweight success ping (kept quiet in normal use)
        // console.debug("[OverlayCore] OK");
      }

      __scheduleAutosave(reason);
    } finally {
      __overlayCommitLocked = false;
    }
  }

  function __overlayHealthCheck(){
    const issues = [];
    const gfx = clips.filter(c => c && c.kind === "gfx");
    const ordered = gfx.slice().sort((a,b) => __overlayCompare(a.overlay, b.overlay));
    const seen = new Set();

    for (let i = 0; i < ordered.length; i++){
      const c = ordered[i];
      const o = c ? c.overlay : null;

      if (!o || typeof o !== "object"){
        issues.push(`GFX clip ${c?.id || "(unknown)"} missing overlay object`);
        continue;
      }
      if (!o.id || typeof o.id !== "string"){
        issues.push(`Overlay missing id on gfx clip ${c?.id || "(unknown)"}`);
      } else if (seen.has(o.id)){
        issues.push(`Duplicate overlay id: ${o.id}`);
      } else {
        seen.add(o.id);
      }

      if (o.schemaVersion !== 1) issues.push(`Overlay ${o.id || "(unknown)"} schemaVersion != 1`);
      if (!o.type) issues.push(`Overlay ${o.id || "(unknown)"} missing type`);
      if (!o.timing || typeof o.timing.start !== "number" || typeof o.timing.dur !== "number"){
        issues.push(`Overlay ${o.id || "(unknown)"} invalid timing`);
      }
      if (!o.transform || typeof o.transform.xPct !== "number" || typeof o.transform.yPct !== "number"){
        issues.push(`Overlay ${o.id || "(unknown)"} invalid transform`);
      }
      if (!o.style || typeof o.style.preset !== "string"){
        issues.push(`Overlay ${o.id || "(unknown)"} invalid style`);
      }

      const desired = (i + 1) * 10;
      if (typeof o.zIndex === "number" && o.zIndex !== desired){
        // Not fatal; normalization will correct.
        // Keep as warning for transparency.
        issues.push(`Overlay ${o.id || "(unknown)"} zIndex ${o.zIndex} != ${desired} (will normalize)`);
      }
    }

    return { ok: issues.length === 0, issues };
  }

  let __autosaveTimer = null;
  function __scheduleAutosave(reason){
    try{
      clearTimeout(__autosaveTimer);
      __autosaveTimer = setTimeout(() => __autosaveNow(reason), 400);
    }catch(_e){}
  }

  function __autosaveNow(reason){
    try{
      const payload = __buildWarcutPayload();
      const json = __stringifyWarcutPayload(payload);
      localStorage.setItem(__AUTOSAVE_KEY, json);
      localStorage.setItem(__AUTOSAVE_META_KEY, JSON.stringify({
        ts: Date.now(),
        reason: String(reason || ""),
        schemaVersion: WARCUT_SCHEMA_VERSION
      }));
      // Non-intrusive: no UI spam
    }catch(e){
      console.warn("[Warcut] Autosave failed:", e);
    }
  }

  function __tryRestoreAutosave(){
    try{
      // Safety gate: only auto-restore when starting from an empty session.
      if ((media && media.length) || (clips && clips.length)) return false;

      const s = localStorage.getItem(__AUTOSAVE_KEY);
      if (!s) return false;


      // Blob/Object URLs created from local file imports cannot survive reloads.
      // If an autosave contains blob:/file: URLs, it will spam ERR_FILE_NOT_FOUND and break interaction.
      // On server-hosted sessions this is never restorable, so we skip it unless ?restore=1 is present.
      const __qs = new URLSearchParams(location.search || "");
      const __forceRestore = __qs.has("restore") || __qs.has("force_restore");
      const __skipRestore = __qs.has("new") || __qs.has("reset") || __qs.has("fresh");
      if (__skipRestore){
        console.info("[Warcut] Autosave skipped (forced new project via query string).");
        try{ __clearAutosave(); }catch(_e){}
        try{ setStatus("New project (autosave cleared)."); }catch(_e){}
        return false;
      }

      if (!__forceRestore && (/\bblob:/i.test(s) || /\bfile:/i.test(s))){
        console.info("[Warcut] Autosave skipped (contains non-restorable local media URLs).");
        try{ __clearAutosave(); }catch(_e){}
        try{ setStatus("Autosave skipped (local media cannot be restored after reload)."); }catch(_e){}
        return false;
      }

      const payload = JSON.parse(s);
      if (!payload || payload.fileType !== "warcut") return false;

      __loadWarcutPayload(payload);
      setStatus("Autosave restored.");
      console.info("[Warcut] Autosave restored (Stage 5).");
      return true;
    }catch(e){
      console.warn("[Warcut] Autosave restore failed:", e);
      return false;
    }
  }

  function __clearAutosave(){
    try{
      localStorage.removeItem(__AUTOSAVE_KEY);
      localStorage.removeItem(__AUTOSAVE_META_KEY);
      return true;
    }catch(_e){
      return false;
    }
  

  function __revokeSessionObjectUrls(){
    try{
      for (const m of (media || [])){
        const u = String(m?.url || "");
        if (u.startsWith("blob:")){
          try{ URL.revokeObjectURL(u); }catch(_e){}
        }
      }
    }catch(_e){}
    try{
      for (const u of Array.from(__SESSION_BLOB_URLS)){
        try{ URL.revokeObjectURL(u); }catch(_e){}
      }
    }catch(_e){}
    try{ __SESSION_BLOB_URLS.clear(); }catch(_e){}
  }

  function hardResetProject(){
    try{ pause(); }catch(_e){}
    try{ stopAudio(); }catch(_e){}
    try{ previewVideo.pause(); }catch(_e){}
    try{ previewVideo.removeAttribute("src"); previewVideo.load(); }catch(_e){}

    try{ __revokeSessionObjectUrls(); }catch(_e){}
    try{ __clearAutosave(); }catch(_e){}

    media = [];
    clips = [];
    selectedMediaId = null;
    selectedClipId = null;
    playhead = 0;

    try{ updateBin(); }catch(_e){}
    try{ renderTimeline(); }catch(_e){}
    try{ renderOverlays(); }catch(_e){}
    try{ renderInspector(); }catch(_e){}
    try{ updatePlayheadEl(); }catch(_e){}
    try{ setStatus("New project."); }catch(_e){}
  }

}

  // Deterministic JSON stringify (stable key ordering)
  function __stableStringify(value, opts){
    const space = (opts && typeof opts.space === "number") ? opts.space : 2;

    const ROOT_ORDER = ["app","fileType","schemaVersion","version","project","media","timeline","overlays"];
    const PROJECT_ORDER = ["name","fps"];
    const OVERLAY_ORDER = ["schemaVersion","id","type","enabled","solo","zIndex","timing","transform","style","motion"];
    const TIMING_ORDER = ["start","dur","in","out"];
    const TRANSFORM_ORDER = ["xPct","yPct","scale","rot"];
    const STYLE_ORDER = ["preset","kicker","title","subtitle","font","size","weight","color","bg","padding"];
    const TIMELINE_ORDER = ["id","kind","track","start","dur","in","out","muted","src","overlayId","zIndex","enabled","solo","kicker","title","subtitle","stylePreset","x","y","scale","motion"];
    const MEDIA_ORDER = ["id","kind","name","src","type","duration","w","h","fps","audio"];

    const isPlainObject = (o) => o && typeof o === "object" && Object.getPrototypeOf(o) === Object.prototype;

    const orderedObject = (obj, order, ctxKey) => {
      const out = {};
      const used = new Set();
      for (const k of order){
        if (Object.prototype.hasOwnProperty.call(obj, k)){
          used.add(k);
          out[k] = stabilize(obj[k], k);
        }
      }
      const rest = Object.keys(obj).filter(k => !used.has(k)).sort((a,b)=>a.localeCompare(b));
      for (const k of rest){
        out[k] = stabilize(obj[k], k);
      }
      return out;
    };

    const stabilize = (v, keyHint) => {
      if (Array.isArray(v)){
        return v.map(x => stabilize(x, keyHint));
      }
      if (!isPlainObject(v)) return v;

      // Root
      if (keyHint === "" && v.fileType === "warcut"){
        return orderedObject(v, ROOT_ORDER, "root");
      }

      // Known shapes
      if (v && v.schemaVersion === 1 && v.timing && v.transform && v.style){
        return orderedObject(v, OVERLAY_ORDER, "overlay");
      }
      if (keyHint === "project"){
        return orderedObject(v, PROJECT_ORDER, "project");
      }
      if (keyHint === "timing"){
        return orderedObject(v, TIMING_ORDER, "timing");
      }
      if (keyHint === "transform"){
        return orderedObject(v, TRANSFORM_ORDER, "transform");
      }
      if (keyHint === "style"){
        return orderedObject(v, STYLE_ORDER, "style");
      }
      if (v && typeof v.kind === "string" && typeof v.start === "number" && typeof v.dur === "number"){
        return orderedObject(v, TIMELINE_ORDER, "timeline");
      }
      if (v && typeof v.id === "string" && typeof v.kind === "string" && (v.src || v.name)){
        return orderedObject(v, MEDIA_ORDER, "media");
      }

      // Fallback: alphabetical keys
      return orderedObject(v, Object.keys(v).sort((a,b)=>a.localeCompare(b)), "obj");
    };

    const stabilized = stabilize(value, "");
    return JSON.stringify(stabilized, null, space);
  }

  // Best-effort overlay bulk update (debug / tooling entry point)
  function __setOverlays(nextOverlays, reason){
    if (!Array.isArray(nextOverlays)) throw new Error("setOverlays expects an array");
    const byId = new Map(
      clips.filter(c => c && c.kind === "gfx").map(c => [String((c.overlay?.id || c.id || "")), c])
    );
    for (const ov of nextOverlays){
      const id = String(ov?.id || "");
      if (!id) continue;
      const c = byId.get(id);
      if (!c) continue;
      applyOverlayToGfxClip(c, ov);
    }
    __scheduleOverlayCommit(reason || "setOverlays");
    return true;
  }

  // Kick autosave restore after the UI is wired
  setTimeout(() => { try{ __tryRestoreAutosave(); }catch(_e){} }, 0);


  function __snapshotState(){
    // Only timeline-related state (media bin/import is intentionally excluded)
    return JSON.stringify({
      clips,
      selectedClipId,
      playhead,
      snapOn,
      rippleOn,
      gfxPreviewOn
    });
  }

  function __restoreState(serialized){
    try{
      const s = JSON.parse(serialized);
      clips = Array.isArray(s.clips) ? s.clips : clips;
      selectedClipId = s.selectedClipId ?? null;
      playhead = Number(s.playhead) || 0;
      snapOn = !!s.snapOn;
      rippleOn = !!s.rippleOn;
      gfxPreviewOn = (s.gfxPreviewOn !== undefined) ? !!s.gfxPreviewOn : gfxPreviewOn;
    }catch(_e){}

    // Phase A / Stage 1: ensure restored history state has valid overlay objects
    try{ __normalizeAllGfxClips(); }catch(_e){}

    // Phase A / Stage 2: enforce deterministic ordering + z-index normalization after restores
    try{ __normalizeOverlayOrdering(); }catch(_e){}

    snapState.textContent = snapOn ? "On" : "Off";
    rippleState.textContent = rippleOn ? "On" : "Off";
    previewGfxState.textContent = gfxPreviewOn ? "On" : "Off";
    updateCounts();
    buildRuler();
    renderTimeline();
    renderInspector();
    renderOverlays();
    seekPreviewTo(playhead);
    playheadSecLabel.textContent = playhead.toFixed(2);
    timeReadout.textContent = fmtTime(playhead);
    updatePlayheadEl();
    ensurePlayheadVisible();
    syncActiveClipChip();
  }

  function __pushUndo(label){
    undoStack.push({ label: label || "Change", state: __snapshotState() });
    if (undoStack.length > 80) undoStack.shift();
    redoStack = [];
    __updateUndoRedoButtons();
  }

  function __updateUndoRedoButtons(){
    if (undoBtn) undoBtn.disabled = undoStack.length === 0;
    if (redoBtn) redoBtn.disabled = redoStack.length === 0;
  }

  function undo(){
    if (!undoStack.length) return;
    const cur = __snapshotState();
    const prev = undoStack.pop();
    redoStack.push({ label: prev.label, state: cur });
    __restoreState(prev.state);
    setStatus("Undid: " + prev.label);
    __updateUndoRedoButtons();
  }

  function redo(){
    if (!redoStack.length) return;
    const cur = __snapshotState();
    const next = redoStack.pop();
    undoStack.push({ label: next.label, state: cur });
    __restoreState(next.state);
    setStatus("Redid: " + next.label);
    __updateUndoRedoButtons();
  }

  function fmtTime(sec){
    sec = Math.max(0, Number(sec)||0);
    const m = Math.floor(sec/60);
    const s = sec - m*60;
    return String(m).padStart(2,"0") + ":" + s.toFixed(3).padStart(6,"0");
  }

  function setStatus(msg){
    statusHint.textContent = msg;
  }

  function updateMasterMuteBtn(){
    if (!masterMuteBtn) return;
    masterMuteBtn.textContent = masterMuted ? "üîá" : "üîä";
    masterMuteBtn.title = masterMuted ? "Unmute preview" : "Mute preview";
  }

  function setCodecStatus(text, ok){
    codecText.textContent = text;
    const dot = codecChip.querySelector(".dot");
    dot.classList.toggle("ok", !!ok);
    dot.classList.toggle("warn", !ok);
  }

  
  // ---- Codec Support Report (Roadmap 0.C) ----
  let lastCodecMediaId = null;

  function openCodecModal(){
    codecModal.classList.add("show");
    codecModal.setAttribute("aria-hidden","false");
  }
  function closeCodecModal(){
    codecModal.classList.remove("show");
    codecModal.setAttribute("aria-hidden","true");
  }

  codecClose.addEventListener("click", closeCodecModal);
  codecOk.addEventListener("click", closeCodecModal);
  codecModal.addEventListener("click", (e) => {
    if (e.target === codecModal) closeCodecModal();
  });

  codecChip.addEventListener("click", () => {
    openCodecModal();
  });

  function _errCodeName(code){
    return ({
      1:"MEDIA_ERR_ABORTED",
      2:"MEDIA_ERR_NETWORK",
      3:"MEDIA_ERR_DECODE",
      4:"MEDIA_ERR_SRC_NOT_SUPPORTED"
    })[code] || ("ERR_" + code);
  }

  async function probeDecode(url){
    const v = document.createElement("video");
    v.muted = true;
    v.playsInline = true;
    v.preload = "auto";
    v.src = url;

    const out = { loadedmetadata:false, loadeddata:false, canplay:false, play:false, err:null };

    return await new Promise((resolve) => {
      let done = false;
      const finish = () => {
        if (done) return;
        done = true;
        try{ v.pause(); }catch(_e){}
        v.removeAttribute("src");
        v.load();
        resolve(out);
      };

      v.addEventListener("loadedmetadata", () => { out.loadedmetadata = true; out.w=v.videoWidth; out.h=v.videoHeight; out.dur=v.duration; });
      v.addEventListener("loadeddata", () => { out.loadeddata = true; });
      v.addEventListener("canplay", () => { out.canplay = true; });

      v.addEventListener("error", () => {
        out.err = v.error ? { code:v.error.code, name:_errCodeName(v.error.code) } : { code:0, name:"UNKNOWN" };
        finish();
      }, { once:true });

      // Try play (muted) once data is there; also safety timeout
      v.addEventListener("canplay", async () => {
        try{
          await v.play();
          v.pause();
          out.play = true;
        }catch(e){
          out.play = false;
          out.playErr = e?.name || String(e);
        }
        finish();
      }, { once:true });

      setTimeout(finish, 1500);
    });
  }

  async function refreshCodecUI(m){
    if (!m || m.kind !== "video"){
      setCodecStatus("No video selected", false);
      codecReport.innerHTML = "Select a video to view its codec / playback report.";
      lastCodecMediaId = null;
      return;
    }

    // canPlayType is capability-based, not file-specific. Still useful as a baseline.
    const caps = [
      { label:"MP4 container", ct:'video/mp4' },
      { label:"H.264 baseline (avc1.42E01E)", ct:'video/mp4; codecs="avc1.42E01E"' },
      { label:"H.264 main (avc1.4D401E)", ct:'video/mp4; codecs="avc1.4D401E"' },
      { label:"H.264 high (avc1.640028)", ct:'video/mp4; codecs="avc1.640028"' },
      { label:"AAC-LC (mp4a.40.2)", ct:'audio/mp4; codecs="mp4a.40.2"' },
      { label:"HEVC (hvc1) (often unsupported)", ct:'video/mp4; codecs="hvc1.1.6.L120.90"' }
    ].map(x => ({...x, res: (previewVideo.canPlayType(x.ct) || "no") }));

    // Probe once per selection
    if (m.id !== lastCodecMediaId || !m._probe){
      m._probe = await probeDecode(m.url);
      lastCodecMediaId = m.id;
    }

    const ok = !!(m._probe?.play || m._probe?.canplay || m._probe?.loadeddata);
    setCodecStatus(ok ? "Preview OK (probe)" : "Preview uncertain", ok);

    const sizeMB = m.file?.size ? (m.file.size / (1024*1024)).toFixed(2) : "0.00";
    const dims = (m.w && m.h) ? `${m.w}√ó${m.h}` : (m._probe?.w && m._probe?.h ? `${m._probe.w}√ó${m._probe.h}` : "‚Äî");
    const dur = (m.duration || m._probe?.dur) ? (Number(m.duration || m._probe.dur).toFixed(2) + "s") : "‚Äî";

    let html = "";
    html += `<div><b>${escapeHtml(m.name||"video")}</b> <span class="pillmini">${sizeMB} MB</span></div>`;
    html += `<div class="small">Duration: <b>${dur}</b> ¬∑ Dimensions: <b>${dims}</b></div>`;
    html += `<div style="height:10px"></div>`;
    html += `<div class="small"><b>Browser canPlayType (capability)</b></div>`;
    html += `<ul class="small" style="margin:6px 0 0 18px">`;
    for (const c of caps){
      const cls = (c.res === "probably" ? "pillmini ok" : (c.res === "maybe" ? "pillmini warn" : "pillmini"));
      html += `<li>${escapeHtml(c.label)}: <span class="${cls}">${escapeHtml(c.res)}</span></li>`;
    }
    html += `</ul>`;

    html += `<div style="height:10px"></div>`;
    html += `<div class="small"><b>Quick probe (file-specific)</b></div>`;
    if (m._probe?.err){
      html += `<div class="small">Error: <span class="pillmini warn">${escapeHtml(m._probe.err.name)}</span></div>`;
    } else {
      const tag = ok ? "ok" : "warn";
      html += `<div class="small">Result: <span class="pillmini ${tag}">${ok ? "Loaded / decodable" : "Not confirmed"}</span></div>`;
      if (m._probe?.playErr){
        html += `<div class="small">Play attempt: ${escapeHtml(String(m._probe.playErr))}</div>`;
      }
    }

    // Optional: MediaCapabilities (best-effort)
    if (navigator.mediaCapabilities?.decodingInfo){
      try{
        const cfg = {
          type: "file",
          video: {
            contentType: 'video/mp4; codecs="avc1.640028"',
            width: (m.w || m._probe?.w || 1920),
            height:(m.h || m._probe?.h || 1080),
            bitrate: 8_000_000,
            framerate: Number(fpsSelect.value) || 30
          }
        };
        const info = await navigator.mediaCapabilities.decodingInfo(cfg);
        html += `<div style="height:10px"></div>`;
        html += `<div class="small"><b>MediaCapabilities (best-effort)</b></div>`;
        html += `<div class="small">Supported: <span class="pillmini ${info.supported ? "ok" : "warn"}">${info.supported}</span> ¬∑ Smooth: <span class="pillmini ${info.smooth ? "ok" : "warn"}">${info.smooth}</span> ¬∑ PowerEfficient: <span class="pillmini ${info.powerEfficient ? "ok" : "warn"}">${info.powerEfficient}</span></div>`;
      }catch(_e){
        // ignore
      }
    }

    codecReport.innerHTML = html;
  }

function updateCounts(){
    binCount.textContent = String(media.length);
    const v = clips.filter(c=>c.track==="v1").length;
    const g = clips.filter(c=>c.track==="gfx").length;
    const a = clips.filter(c=>c.track==="a1").length;
    v1Count.textContent = String(v);
    gfxCount.textContent = String(g);
    a1Count.textContent = String(a);
    timelineLenLabel.textContent = (getTimelineLength()).toFixed(2);
    lanes.style.setProperty("--timelineLen", String(Math.max(5, Math.ceil(getTimelineLength()+2))));
  }

  function getPxPerSec(){
    return Number(getComputedStyle(document.documentElement).getPropertyValue("--pxPerSec")) || 84;
  }

  function setPxPerSec(v){
    // Wider zoom range: allow very condensed timelines for long audio/narration.
    v = Math.max(1, Math.min(1000, v|0));
document.documentElement.style.setProperty("--pxPerSec", v);
    zoomScaleVal.textContent = String(v);
    buildRuler();
    renderTimeline();
  }

  zoomScale.addEventListener("input", () => setPxPerSec(Number(zoomScale.value)));

  projectNameInput.addEventListener("input", () => {
    const v = projectNameInput.value.trim() || "Untitled.warcut";
    projectName.textContent = v;
  });

  importBtn.addEventListener("click", () => fileInput.click());

  fileInput.addEventListener("change", async () => {
    const files = Array.from(fileInput.files || []);
    fileInput.value = "";
    if (!files.length) return;

    for (const f of files){
      const name = f.name || "untitled";
      const type = (f.type || "").toLowerCase();

      if (type.startsWith("video/") || name.toLowerCase().endsWith(".mp4")){
        await addVideoMedia(f, name);
      } else if (type.startsWith("audio/")){
        await addAudioMedia(f, name);
      } else if (type.startsWith("image/")){
        await addImageMedia(f, name);
      } else {
        // ignore
      }
    }

    updateBin();
    updateCounts();
    setStatus("Imported media ¬∑ Double-click items to add to the timeline.");
  });

  async function addVideoMedia(file, name){
    const url = URL.createObjectURL(file);
    try{ __rememberSessionBlobUrl(url); }catch(_e){}// probe with a temp video element
    const v = document.createElement("video");
    v.preload = "metadata";
    v.src = url;
    const meta = await new Promise((resolve) => {
      const done = () => resolve({
        duration: isFinite(v.duration) ? v.duration : 0,
        w: v.videoWidth || 0,
        h: v.videoHeight || 0,
        canPlay: v.canPlayType("video/mp4; codecs=\"avc1.42E01E\"") || v.canPlayType("video/mp4") || ""
      });
      v.onloadedmetadata = done;
      v.onerror = () => resolve({duration:0,w:0,h:0,canPlay:""});
      // safety timeout
      setTimeout(done, 800);
    });

    const can = String(meta.canPlay || "").length > 0;
    setCodecStatus(
      can ? "Codec support: browser canPlayType(video/mp4) ‚úî" : "Codec support: may fail (HEVC/unsupported) ‚ö†",
      can
    );

    media.push({
      id: uid(),
      kind: "video",
      name,
      file,
      url,
      duration: meta.duration || 0,
      w: meta.w || 0,
      h: meta.h || 0
    });
  }

  async function addAudioMedia(file, name){
  const url = URL.createObjectURL(file);
    try{ __rememberSessionBlobUrl(url); }catch(_e){}

  // Create entry immediately so it's usable even if metadata is slow.
  const id = uid();
  const entry = { id, kind:"audio", name, file, url, duration: 0 };
  media.push(entry);

  // Update UI promptly (so the item appears in the bin).
  try{ updateBin(); }catch(_e){}

  // Probe duration via <audio> metadata. Some containers (e.g. m4a without faststart)
  // can take longer; we keep listening and patch the duration when it becomes known.
  const a = document.createElement("audio");
  a.preload = "metadata";
  a.src = url;

  const applyDur = (dur) => {
    if (!(isFinite(dur) && dur > 0)) return;
    entry.duration = dur;

    // Any timeline clips referencing this audio should expand to the true length.
    for (const c of clips){
      if (c.kind === "audio" && c.mediaId === id){
        c.in = 0;
        c.out = dur;
        c.dur = dur;
        c.__durLocked = true;
      }
    }
    try{ updateCounts(); }catch(_e){}
    try{ renderTimeline(); }catch(_e){}
    try{ renderInspector(); }catch(_e){}
    try{ updateBin(); }catch(_e){}
  };

  // Best case: metadata arrives quickly.
  a.addEventListener("loadedmetadata", () => {
    try{ applyDur(a.duration); }catch(_e){}
  }, { once:true });

  // Fallback: if metadata stalls, poll a few times (non-blocking).
  let tries = 0;
  const poll = () => {
    tries++;
    try{
      if (isFinite(a.duration) && a.duration > 0){
        applyDur(a.duration);
        return;
      }
    }catch(_e){}
    if (tries < 10) setTimeout(poll, 800);
  };
  setTimeout(poll, 800);
}

async function addImageMedia(file, name){
    const url = URL.createObjectURL(file);
    try{ __rememberSessionBlobUrl(url); }catch(_e){}
    let w = 0, h = 0;
    try{
      const img = await loadImage(url);
      w = img?.naturalWidth || img?.width || 0;
      h = img?.naturalHeight || img?.height || 0;
    }catch(_e){ /* ignore */ }
    media.push({ id: uid(), kind:"image", name, file, url, w, h });
  }

  function updateBin(){
    binList.innerHTML = "";
    if (!media.length){
      binList.innerHTML = `<div class="hint warn"><b>Mockup note:</b> import MP4/audio/images to populate the bin.</div>`;
      addToTimelineBtn.disabled = true;
      removeMediaBtn.disabled = true;
      return;
    }

    for (const m of media){
      const card = document.createElement("div");
      card.className = "media-item";
      card.dataset.id = m.id;

      const icon = m.kind === "video" ? "‚ñ∂" : (m.kind === "audio" ? "‚ô™" : "‚ñ¶");
      let thumbInner = `<div style="font-size:18px;opacity:.9">${icon}</div>`;
      if (m.kind === "image") thumbInner = `<img alt="" src="${m.url}">`;

      const dur = m.duration ? `${m.duration.toFixed(2)}s` : "‚Äî";
      const dims = (m.w && m.h) ? `${m.w}√ó${m.h}` : "‚Äî";

      card.innerHTML = `
        <div class="thumb">${thumbInner}</div>
        <div style="min-width:0">
          <div class="m-title" title="${escapeHtml(m.name)}">${escapeHtml(m.name)}</div>
          <div class="m-meta">
            <span class="pillmini">${m.kind.toUpperCase()}</span>
            <span class="pillmini">Dur: <span class="mono">${dur}</span></span>
            <span class="pillmini">Dim: <span class="mono">${dims}</span></span>
          </div>
        </div>
      `;

      card.addEventListener("click", () => {
        selectedMediaId = m.id;
        $$(".media-item", binList).forEach(el => el.classList.toggle("active", el.dataset.id === m.id));
        addToTimelineBtn.disabled = false;
        removeMediaBtn.disabled = false;
        refreshCodecUI(m).catch(()=>{});
      });

      card.addEventListener("dblclick", () => {
        selectedMediaId = m.id;
        addSelectedMediaToTimeline();
      });

      binList.appendChild(card);
    }
    addToTimelineBtn.disabled = !selectedMediaId;
    removeMediaBtn.disabled = !selectedMediaId;
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  removeMediaBtn.addEventListener("click", () => {
    if (!selectedMediaId) return;
    // prevent removing media in use
    const inUse = clips.some(c => c.mediaId === selectedMediaId);
    if (inUse){
      setStatus("Cannot remove: media is used in the timeline.");
      return;
    }
    const idx = media.findIndex(m => m.id === selectedMediaId);
    if (idx >= 0){
      __pushUndo("Delete clip");
      const m = media[idx];
      try{ URL.revokeObjectURL(m.url); }catch(e){}
      media.splice(idx, 1);
      selectedMediaId = null;
      updateBin();
      updateCounts();
      setStatus("Removed media item.");
    }
  });

  addToTimelineBtn.addEventListener("click", addSelectedMediaToTimeline);

  function getTimelineLength(){
    let maxEnd = 0;
    for (const c of clips){
      maxEnd = Math.max(maxEnd, c.start + c.dur);
    }
    return maxEnd;
  }

  function addSelectedMediaToTimeline(){
    const m = media.find(x => x.id === selectedMediaId);
    if (!m) return;

    const t = playhead; // place at playhead by default
    if (m.kind === "video"){
      const dur = Math.max(0.5, Number(m.duration)||4);
      __pushUndo("Add video clip");
      addClip({
        track:"v1",
        kind:"video",
        mediaId:m.id,
        start: t,
        dur: dur,
        in: 0,
        out: dur,
        clipAudioMuted: true
      });
      setStatus(`Added video to V1 at ${t.toFixed(2)}s.`);
    } else if (m.kind === "audio"){
      __pushUndo("Add audio clip");
      const dur = Math.max(0.25, (Number(m.duration) > 0 ? Number(m.duration) : 4));
      addClip({
        track:"a1",
        kind:"audio",
        __durLocked: true,
        mediaId:m.id,
        start: t,
        dur: dur,
        in: 0,
        out: dur
      });
      setStatus(`Added audio to A1 at ${t.toFixed(2)}s.`);
    } else if (m.kind === "image"){
      // Phase 4A: allow imported PNGs/images to be used as an overlay clip on the GFX track
      const dur = 3.0;
      __pushUndo("Add image overlay");
      const ov = ensureOverlaySchema({
        type: OVERLAY_TYPES.IMAGE,
        timing: { start: t, dur },
        transform: { xPct: 4.5, yPct: 7, scale: 1 },
        layer: "overlay",
        asset: {
          kind: "image",
          url: m.url,
          name: m.name,
          w: m.w || 0,
          h: m.h || 0,
          fit: "contain",
          opacity: 1
        },
        motion: { preset: "fade" }
      });

      const item = addClip({
        track:"gfx",
        kind:"gfx",
        gfxType:"image",
        mediaId:m.id, // keeps delete-guard parity (media in use)
        start: t,
        dur,
        x: ov.transform.xPct,
        y: ov.transform.yPct,
        scale: ov.transform.scale,
        motion: "fade",
        overlay: ov
      });
      applyOverlayToGfxClip(item, ov);
      selectClip(item.id);
      setStatus(`Added image overlay to GFX at ${t.toFixed(2)}s (duration default 3s; adjust in Inspector).`);
    } else {
      setStatus("Unsupported media type.");
      return;
    }

    updateCounts();
    buildRuler();
    renderTimeline();
  }

  // Add Lower Third
addLowerThirdBtn.addEventListener("click", () => {
  const t = playhead;
  __pushUndo("Add lower third");

  const item = addClip({
    track:"gfx",
    kind:"gfx",
    start: t,
    dur: 3.0,
    kicker: "WARCHIEF",
    title: "Lower Third Title",
    subtitle: "Subtitle / role / location",
    stylePreset: "news",
    x: 4.5,
    y: 7,
    scale: 1,
    motion: "fade"
  });

  // Keep canonical overlay schema aligned and selection stable
  try{ applyOverlayToGfxClip(item, overlayFromGfxClip(item), {silent:true}); }catch(_e){}
  try{ __normalizeOverlayOrdering(true); }catch(_e){}

  selectClip(item.id);
  setStatus(`Added lower third at ${t.toFixed(2)}s.`);
  updateCounts();
  buildRuler();
  renderTimeline();
  renderOverlays();
  renderInspector();
});

function addClip(props){
    const id = uid();
    const c = Object.assign({
      id,
      track:"v1",
      kind:"video",
      mediaId:null,
      start:0,
      dur:3,
      in:0,
      out:3,
      title:"",
      subtitle:"",
      kicker:"",
      stylePreset:"news",
      x: 4.5,
      y: 7,
      scale: 1,
      motion: "fade",
      clipAudioMuted:false
    }, props || {});

    // Phase A / Stage 1: normalize GFX clips into a unified overlay schema (without changing UI behavior)
    if (c.kind === "gfx"){
      applyOverlayToGfxClip(c, overlayFromGfxClip(c));
    }

    clips.push(c);

    // Phase A / Stage 2: enforce deterministic ordering + z-index normalization
    if (c.kind === "gfx"){
      try{ __normalizeOverlayOrdering(); }catch(_e){}
    }

    return c;
  }

  // Timeline build
  let rulerInner = null;

  function buildRuler(){
    const px = getPxPerSec();
    const len = Math.max(10, Math.ceil(getTimelineLength() + 2));

    ruler.innerHTML = "";
    rulerInner = document.createElement("div");
    rulerInner.className = "ruler-inner";
    ruler.appendChild(rulerInner);

    // Label density adapts to zoom to avoid a wall of text.
    const majorStep =
      (px >= 140) ? 1 :
      (px >= 95)  ? 2 :
      (px >= 70)  ? 5 :
      (px >= 50)  ? 10 : 15;

    for (let s = 0; s <= len; s++){
      const tick = document.createElement("div");
      const isMajor = (s % majorStep) === 0;
      tick.className = "rtick" + (isMajor ? " major" : "");
      tick.style.left = secToX(s) + "px";
      rulerInner.appendChild(tick);

      if (isMajor){
        const lab = document.createElement("div");
        lab.className = "rlabel";
        lab.textContent = s + "s";
        lab.style.left = secToX(s) + "px";
        rulerInner.appendChild(lab);
      }
    }

    lanes.style.setProperty("--timelineLen", String(len));
    syncRulerToScroll();
  }

  function syncRulerToScroll(){
    if (!rulerInner) return;
    // laneScroll is the truth; we visually offset the ruler instead of making it scrollable
    rulerInner.style.transform = `translateX(${-laneScroll.scrollLeft}px)`;
  }

  // Keep the ruler aligned with the horizontally scrolling lanes.
  laneScroll.addEventListener("scroll", syncRulerToScroll, { passive: true });
  window.addEventListener("resize", syncRulerToScroll);

  function secToX(sec){ return sec * getPxPerSec(); }
  function xToSec(x){ return x / getPxPerSec(); }

  function renderTimeline(){
    laneV1.innerHTML = "";
    laneGFX.innerHTML = "";
    laneA1.innerHTML = "";

    for (const c of clips){
      const lane = c.track === "v1" ? laneV1 : (c.track === "gfx" ? laneGFX : laneA1);
      const div = document.createElement("div");
      div.className = "clip " + (c.kind === "audio" ? "audio no-trim" : (c.kind === "gfx" ? "gfx" : ""));
      div.dataset.clipId = c.id;


      // __stage3_timeline_class Phase A / Stage 3: reflect overlay visibility flags on the timeline clips (preview aid)
      if (c.kind === "gfx"){
        const en = (c.overlay?.enabled ?? c.enabled ?? true);
        const so = (c.overlay?.solo ?? c.solo ?? false);
        if (!en) div.classList.add("disabled");
        if (so) div.classList.add("solo");
      }
      const left = secToX(c.start);
      const width = Math.max(18, secToX(c.dur));
      div.style.left = left + "px";
      div.style.width = width + "px";

      const label = c.kind === "gfx"
        ? ((String(c.overlay?.type || overlayFromGfxClip(c).type) === OVERLAY_TYPES.IMAGE)
            ? (c.overlay?.asset?.name || c.assetName || media.find(m => m.id === c.mediaId)?.name || "Image")
            : (c.title || "Lower Third"))
        : (media.find(m => m.id === c.mediaId)?.name || (c.kind === "audio" ? "Audio" : "Clip"));

      div.innerHTML = `
        <div class="handle left" data-h="l" title="Trim (mock)"></div>
        <div class="handle right" data-h="r" title="Trim (mock)"></div>
        <div class="cname">${escapeHtml(label)}</div>
        <div class="ctime"><span class="mono">${c.start.toFixed(2)}</span>s ¬∑ <span class="mono">${c.dur.toFixed(2)}</span>s</div>
      `;

      div.addEventListener("click", (e) => {
        e.stopPropagation();
        selectClip(c.id);
      });

      // drag move and trim (lightweight)
      wireClipDrag(div, c);

      lane.appendChild(div);
    }

    // highlight selected
    $$(".clip").forEach(el => el.classList.toggle("active", el.dataset.clipId === selectedClipId));

    updatePlayheadEl();
  }

  function wireClipDrag(el, clip){
  // Robust clip move/trim for mouse + touch + pen (pointer events).
  // Hotfixes:
  //  - Avoids re-rendering the whole timeline while dragging (which destroys the element mid-drag).
  //  - Adds lostpointercapture/blur cleanup so interactions never "lock up".
  //  - Pauses playback when editing so tick re-renders don't fight the gesture.
  let mode = null; // "move" | "trimL" | "trimR"
  let pointerId = null;
  let startX = 0;
  let origStart = 0;
  let origDur = 0;
  let origEnd = 0;
  let active = false;

  const isGfx = () => !!(clip && clip.kind === "gfx");

  const syncOverlayTiming = () => {
    if (!isGfx() || !clip.overlay) return;
    try{
      clip.overlay.timing.start = +clip.start || 0;
      clip.overlay.timing.dur = +clip.dur || 0.25;
    }catch(_e){}
  };

  const liveUpdateEl = () => {
    try{
      const pps = getPxPerSec();
      el.style.left = ((+clip.start||0) * pps) + "px";
      el.style.width = (Math.max(0.25, (+clip.dur||0.25)) * pps) + "px";
      const monos = el.querySelectorAll(".ctime .mono");
      if (monos && monos.length >= 2){
        monos[0].textContent = (+clip.start||0).toFixed(2);
        monos[1].textContent = (+clip.dur||0.25).toFixed(2);
      }
    }catch(_e){}
  };

  const cleanup = (ev) => {
    if (!active) return;
    active = false;

    try{
      if (pointerId != null && el && el.releasePointerCapture){
        el.releasePointerCapture(pointerId);
      }
    }catch(_e){}

    try{ window.removeEventListener("pointermove", onMoveEv); }catch(_e){}
    try{ window.removeEventListener("pointerup", cleanup); }catch(_e){}
    try{ window.removeEventListener("pointercancel", cleanup); }catch(_e){}
    try{ window.removeEventListener("blur", cleanup); }catch(_e){}
    try{ el.removeEventListener("lostpointercapture", cleanup); }catch(_e){}

    // Ripple trim (v1): when trimming the right edge, optionally push chain.
    if (rippleOn && mode === "trimR"){
      const newEnd = (+clip.start||0) + (+clip.dur||0);
      const delta = newEnd - origEnd;
      if (Math.abs(delta) > 1e-6){
        const eps = 0.05;
        const sameTrack = clips
          .filter(c => c.track === clip.track && c.id !== clip.id)
          .sort((a,b) => a.start - b.start);

        const next = sameTrack.find(c => c.start >= (origEnd - eps));
        if (next && Math.abs(next.start - origEnd) <= eps){
          for (const c2 of sameTrack){
            if (c2.start >= next.start - 1e-6){
              c2.start = Math.max(0, c2.start + delta);
            }
          }
          // Keep overlay schema aligned for any moved gfx clips.
          try{
            for (const c2 of sameTrack){
              if (c2.kind==="gfx" && c2.overlay){
                c2.overlay.timing.start = +c2.start||0;
              }
            }
          }catch(_e){}
        }
      }
    }

    // Final commit render
    syncOverlayTiming();
    updateCounts();
    buildRuler();
    renderTimeline();
    renderOverlays();
    try{ if (selectedClipId === clip.id) renderInspector(); }catch(_e){}
  };

  const onMove = (clientX) => {
    const dx = clientX - startX;
    const ds = xToSec(dx);
    const snap = snapOn ? 0.25 : 0; // 250ms snap
    const snapIt = (v) => snap ? Math.round(v / snap) * snap : v;

    if (mode === "move"){
      clip.start = Math.max(0, snapIt(origStart + ds));
    } else if (mode === "trimR"){
      clip.dur = Math.max(0.25, snapIt(origDur + ds));
    } else if (mode === "trimL"){
      const newStart = Math.max(0, snapIt(origStart + ds));
      const delta = newStart - origStart;
      clip.start = newStart;
      clip.dur = Math.max(0.25, snapIt(origDur - delta));
    }

    // Keep overlay schema aligned during the interaction (prevents "snap back").
    syncOverlayTiming();

    // Lightweight live update (no full render)
    liveUpdateEl();
    try{ if (isGfx()) renderOverlays(); }catch(_e){}
    try{ if (selectedClipId === clip.id) renderInspector(); }catch(_e){}
  };

  const onMoveEv = (ev) => {
    if (pointerId != null && ev.pointerId != null && ev.pointerId !== pointerId) return;
    ev.preventDefault();
    onMove(ev.clientX);
  };

  const onPointerDown = (e) => {
    // Left mouse OR primary touch/pen
    if (e.button !== undefined && e.button !== 0) return;
    if (!clip) return;

    // Ensure selection always updates (clicking a clip should select it even when pointer handlers prevent native click).
    try{ selectClip(clip.id); }catch(_e){}

    // Pause playback so tick-based rerenders don't fight the drag.
    try{ if (isPlaying) pause(); }catch(_e){}

    // Determine handle mode
    const h = e.target?.dataset?.h;
    if (h === "l") mode = "trimL";
    else if (h === "r") mode = "trimR";
    else mode = "move";

    pointerId = (e.pointerId != null ? e.pointerId : null);
    startX = e.clientX;
    origStart = +clip.start || 0;
    origDur = +clip.dur || 0.25;
    origEnd = origStart + origDur;
    active = true;

    try{ __pushUndo(mode === "move" ? "Move clip" : "Trim clip"); }catch(_e){}

    try{
      if (pointerId != null && el.setPointerCapture) el.setPointerCapture(pointerId);
    }catch(_e){}

    e.preventDefault();
    e.stopPropagation();

    // Attach window listeners so we keep receiving events even if the pointer leaves the element.
    try{ window.addEventListener("pointermove", onMoveEv, {passive:false}); }catch(_e){}
    try{ window.addEventListener("pointerup", cleanup, {once:true, passive:false}); }catch(_e){}
    try{ window.addEventListener("pointercancel", cleanup, {once:true, passive:false}); }catch(_e){}
    try{ window.addEventListener("blur", cleanup, {once:true}); }catch(_e){}
    try{ el.addEventListener("lostpointercapture", cleanup, {once:true}); }catch(_e){}
  };

  el.addEventListener("pointerdown", onPointerDown, {passive:false});

  // Fallback: if pointer events unavailable, keep a basic mouse path.
  if (!("PointerEvent" in window)){
    el.addEventListener("mousedown", (e) => {
      if (e.button !== 0) return;
      if (!clip) return;
      // Delegate to pointerdown-compatible path
      onPointerDown(e);
    }, {passive:false});
  }
}

  // Lane click = set playhead (relative to scroll)
  laneScroll.addEventListener("mousedown", (e) => {
    if (e.button !== 0) return;
    // clicking on a clip will stop propagation in clip handler
    const rect = laneScroll.getBoundingClientRect();
    const x = (e.clientX - rect.left) + laneScroll.scrollLeft - 10; // lane padding
    setPlayhead(xToSec(Math.max(0, x)));
  });
  // Mouse wheel: treat vertical scrolling as horizontal panning for the timeline (Windows mouse friendly).
  // Phase 2.4: Shift+wheel scrolls vertically between lanes/tracks (so you can move V1 ‚áÑ GFX ‚áÑ A1 without the scrollbar).
  laneScroll.addEventListener("wheel", (e) => {
    // Ctrl+wheel is reserved for browser zoom. Do not hijack it; also don't pan the timeline when Ctrl is held.
    if (e.ctrlKey && !e.shiftKey && !e.altKey){
      return; // let the browser handle page zoom
    }

    // Ctrl+Shift+wheel: vertical lane scroll (move between V1 ‚áÑ GFX ‚áÑ A1 without using the scrollbar).
    if (e.ctrlKey && e.shiftKey){
      const dy = (Math.abs(e.deltaY) > 0 ? e.deltaY : e.deltaX);
      laneScroll.scrollTop += dy;
      e.preventDefault();
      return;
    }

    // Alt+wheel: zoom timeline (since Ctrl+wheel is browser zoom).
    if (e.altKey){
      e.preventDefault();
      const cur = Number(zoomScale.value)||getPxPerSec();
      const dir = (e.deltaY > 0 ? -1 : 1);
      const next = Math.max(Number(zoomScale.min||0.2), Math.min(Number(zoomScale.max||240), cur + dir * 6));
      zoomScale.value = String(next);
      setPxPerSec(next);
      return;
    }

    // Default: pan horizontally with the wheel.
    laneScroll.scrollLeft += (Math.abs(e.deltaX) > 0 ? e.deltaX : e.deltaY);
    e.preventDefault();
  }, {passive:false});



  function setPlayhead(sec){
    playhead = Math.max(0, sec);
    playheadSecLabel.textContent = playhead.toFixed(2);
    timeReadout.textContent = fmtTime(playhead);
    updatePlayheadEl();
    ensurePlayheadVisible();
    renderOverlays();
    syncActiveClipChip();
    if (isPlaying){
      // restart preview at new time for stability
      startPreviewAt(playhead);
    } else {
      // seek preview to correct clip without playing
      seekPreviewTo(playhead);
    }
  }

  function updatePlayheadEl(){
    const x = secToX(playhead) + 10; // lane padding
    playheadEl.style.transform = `translateX(${x}px)`;
  }

  function ensurePlayheadVisible(pad=80){
    try{
      const x = secToX(playhead) + 10; // lane padding
      const left = laneScroll.scrollLeft;
      const right = left + laneScroll.clientWidth;
      if (x < left + pad){
        laneScroll.scrollLeft = Math.max(0, x - pad);
      } else if (x > right - pad){
        laneScroll.scrollLeft = Math.max(0, x - (laneScroll.clientWidth - pad));
      }
    }catch(_e){}
  }


  // Selection
  function selectClip(id){
    selectedClipId = id;
    $$(".clip").forEach(el => el.classList.toggle("active", el.dataset.clipId === selectedClipId));
    const c = clips.find(x=>x.id===id);
    if (!c){ renderInspector(); return; }

    // Tab behavior: don't yank the user away from whatever inspector tab they're using.
    // Only auto-switch if they're currently on the Project tab (or nothing active).
    try{
      const cur = document.querySelector(".tab.active")?.dataset?.tab || "";
      if (!cur || cur === "project"){
        const tabKey = (c.kind === "gfx") ? "gfx" : "clip";
        const tabEl = document.querySelector(`.tab[data-tab="${tabKey}"]`);
        if (tabEl){
          $$(".tab").forEach(t => t.classList.toggle("active", t === tabEl));
          $("#pane-project").classList.toggle("active", tabKey === "project");
          $("#pane-clip").classList.toggle("active", tabKey === "clip");
          $("#pane-gfx").classList.toggle("active", tabKey === "gfx");
        }
      }
    }catch(_e){}
    renderInspector();
  }

  function renderInspector(){
  const c = clips.find(x => x.id === selectedClipId);

  const isGfx = !!(c && (c.kind === "gfx" || c.track === "gfx" || c.gfxType));
  const isAud = !!(c && c.kind === "audio");

  if (!c){
    // clip pane
    clipNone.style.display = "block";
    clipFields.style.display = "none";
    // gfx pane
    gfxNone.style.display = "block";
    gfxFields.style.display = "none";
    return;
  }

  // --- Clip pane (always visible when something is selected) ---
  clipNone.style.display = "none";
  clipFields.style.display = "block";

  clipStart.value = String((c.start || 0).toFixed(2));
  clipDur.value = String((c.dur || 0).toFixed(2));

  if (isGfx){
    // GFX: timing only (no source in/out)
    clipIn.value = "0.00";
    clipOut.value = String((c.dur || 0).toFixed(2));
    muteClipState.textContent = "‚Äî";
  } else {
    clipIn.value = String((c.in || 0).toFixed(2));
    clipOut.value = String(((c.out ?? c.dur) || 0).toFixed(2));
    muteClipState.textContent = (c.clipAudioMuted ? "Muted" : "Live");
  }

  // Disable trim fields where unsupported
  clipDur.disabled = isAud;             // audio duration is locked
  clipIn.disabled = isAud || isGfx;     // no source trims for audio or gfx
  clipOut.disabled = isAud || isGfx;

  if (isAud){
    clipDur.title = "Audio duration is locked to the imported file.";
    clipIn.title = "Audio In/Out not editable in mockup yet.";
    clipOut.title = "Audio In/Out not editable in mockup yet.";
  } else if (isGfx){
    clipDur.title = "Set GFX timing here (start/duration).";
    clipIn.title = "GFX does not use source In/Out trims.";
    clipOut.title = "GFX does not use source In/Out trims.";
  } else {
    clipDur.title = "";
    clipIn.title = "";
    clipOut.title = "";
  }

  // --- GFX pane (only for gfx clips) ---
  if (!isGfx){
    gfxNone.style.display = "block";
    gfxFields.style.display = "none";
    return;
  }

  gfxNone.style.display = "none";
  gfxFields.style.display = "block";

  // Ensure overlay schema is available and up-to-date
  let ov = null;
  try{ ov = (c.overlay || overlayFromGfxClip(c)); }catch(_e){ ov = c.overlay || null; }

  // Determine image vs lower third
  const isImg = !!(ov && (String(ov.type) === OVERLAY_TYPES.IMAGE || String(ov.type) === "image"));

  // Populate common gfx fields
  gfxKicker.value = String(c.kicker || "");
  gfxTitle.value = String(c.title || "");
  gfxSub.value = String(c.subtitle || "");
  gfxStart.value = String((c.start || 0).toFixed(2));
  gfxDur.value = String((c.dur || 0).toFixed(2));
  gfxX.value = String(((c.x ?? 4.5)).toFixed(1));
  gfxY.value = String(((c.y ?? 7)).toFixed(1));
  gfxScale.value = String(((c.scale ?? 1)).toFixed(2));
  gfxMotion.value = String(c.motion || "fade");
  previewGfxState.textContent = gfxPreviewOn ? "On" : "Off";

  // Toggle blocks based on type
  try{
    if (gfxTextFields) gfxTextFields.style.display = isImg ? "none" : "block";
    if (gfxImageFields) gfxImageFields.style.display = isImg ? "block" : "none";
    if (gfxPresetsBlock) gfxPresetsBlock.style.display = isImg ? "none" : "block";
    if (isImg){
      if (gfxLayer) gfxLayer.value = String(ov?.layer || c.layer || "overlay");
      if (gfxFit) gfxFit.value = String(ov?.asset?.fit || c.assetFit || "contain");
      if (gfxOpacity) gfxOpacity.value = String((Number.isFinite(+ov?.asset?.opacity) ? +ov.asset.opacity : 1).toFixed(2));
    }
  }catch(_e){}

  // Stage 3 visibility flags
  const _en = (c.overlay?.enabled ?? c.enabled ?? true);
  const _so = (c.overlay?.solo ?? c.solo ?? false);
  if (gfxEnabledState) gfxEnabledState.textContent = _en ? "On" : "Off";
  if (gfxSoloState) gfxSoloState.textContent = _so ? "On" : "Off";
}

applyClipBtn.addEventListener("click", () => {
    const c = clips.find(x=>x.id===selectedClipId);
    if (!c) return;

    // Clip pane applies to Video + Audio + GFX timing (start/duration).
    __pushUndo("Edit clip");

    const start = clampNum(clipStart.value, 0, 10_000, c.start);

    // Audio clips: duration is locked to the imported file length. Allow moving start only.
    if (c.kind === "audio"){
      c.start = start;
      // Keep out/in at full length when known
      const dur = (Number(c.out) > 0 ? (c.out - (c.in||0)) : c.dur);
      c.dur = Number.isFinite(dur) && dur > 0 ? dur : c.dur;
      updateCounts();
      buildRuler();
      renderTimeline();
      renderOverlays();
      renderInspector();
      setStatus("Audio moved.");
      return;
    }

    const dur = clampNum(clipDur.value, 0.25, 10_000, c.dur);

    if (c.kind === "gfx"){
      c.start = start;
      c.dur = dur;

      // Keep canonical overlay contract synced for exports/preview.
      try{ applyOverlayToGfxClip(c, overlayFromGfxClip(c), {silent:true}); }catch(_e){}
      try{ __normalizeOverlayOrdering(true); }catch(_e){}

      updateCounts();
      buildRuler();
      renderTimeline();
      renderOverlays();
      renderInspector();
      setStatus("GFX timing updated.");
      return;
    }

    // Video (and other non-audio) clips: apply full placement + in/out trims.
    const inV = clampNum(clipIn.value, 0, 10_000, c.in||0);
    const outV = clampNum(clipOut.value, 0.01, 10_000, c.out||dur);

    c.start = start;
    c.dur = dur;
    c.in = Math.max(0, Math.min(inV, outV-0.01));
    c.out = Math.max(c.in+0.01, outV);

    updateCounts();
    buildRuler();
    renderTimeline();
    renderOverlays();
    renderInspector();
    setStatus("Clip updated.");
  });

  muteClipBtn.addEventListener("click", () => {
    const c = clips.find(x=>x.id===selectedClipId);
    if (!c || c.kind==="gfx") return;
    __pushUndo("Toggle clip audio");
    c.clipAudioMuted = !c.clipAudioMuted;
    muteClipState.textContent = c.clipAudioMuted ? "Muted" : "Live";
    // if active clip, apply
    if (getActiveVideoClip(playhead)?.id === c.id){
      previewVideo.muted = masterMuted || !!c.clipAudioMuted;
    }
  });

  applyGfxBtn.addEventListener("click", () => {
    const c = clips.find(x=>x.id===selectedClipId);
    if (!c || c.kind!=="gfx") return;
    __pushUndo("Edit lower third");
    c.kicker = String(gfxKicker.value||"");
    c.title = String(gfxTitle.value||"");
    c.subtitle = String(gfxSub.value||"");
    c.start = clampNum(gfxStart.value, 0, 10_000, c.start);
    c.dur = clampNum(gfxDur.value, 0.25, 10_000, c.dur);
    c.x = clampNum(gfxX.value, -50, 150, c.x ?? 4.5);
    c.y = clampNum(gfxY.value, -50, 150, c.y ?? 7);
    c.scale = clampNum(gfxScale.value, 0.25, 3, c.scale ?? 1);
    c.motion = String(gfxMotion.value || "fade");

    // Image overlay extras (Phase 1): background layer + fit + opacity
    try{
      const ov = (c.overlay || overlayFromGfxClip(c));
      const isImg = (String(ov?.type || "") === OVERLAY_TYPES.IMAGE || String(ov?.type || "") === "image");
      if (isImg){
        const lay = String(gfxLayer?.value || ov?.layer || c.layer || "overlay");
        c.layer = (lay === "bg" || lay === "background") ? "bg" : "overlay";
        c.assetFit = String(gfxFit?.value || ov?.asset?.fit || c.assetFit || "contain");
        c.assetOpacity = clampNum(gfxOpacity?.value, 0, 1, (Number.isFinite(+ov?.asset?.opacity) ? +ov.asset.opacity : 1));
      }
    }catch(_e){}

    // Phase A / Stage 1: keep canonical overlay contract synced
    applyOverlayToGfxClip(c, overlayFromGfxClip(c));

    // Phase A / Stage 2: normalize overlay ordering and z-index
    try{ __normalizeOverlayOrdering(); }catch(_e){}

    updateCounts();
    buildRuler();
    renderTimeline();
    renderOverlays();
    setStatus(((() => { try{ const ov=(c.overlay||overlayFromGfxClip(c)); return (String(ov?.type||"")==="image"||String(ov?.type||"")===OVERLAY_TYPES.IMAGE) ? "Image overlay updated." : "Lower third updated."; }catch(_e){ return "GFX updated."; } })()));
  });

  // Phase 4A/4B UX fix: live-update GFX (lower thirds + image overlays) so
  // position/scale/start/duration edits don't require clicking "Update".
  // This also stabilizes timeline trim behavior across rerenders.
  const __gfxLiveApply = (() => {
    let t = 0;
    return (delay=120) => {
      clearTimeout(t);
      t = setTimeout(() => {
        try{
          const c = clips.find(x=>x.id===selectedClipId);
          if (!c || c.kind !== "gfx") return;

          // Pull values from inspector (numbers default to existing)
          c.start = clampNum(gfxStart.value, 0, 10_000, c.start);
          c.dur = clampNum(gfxDur.value, 0.25, 10_000, c.dur);
          c.x = clampNum(gfxX.value, -50, 150, c.x ?? 4.5);
          c.y = clampNum(gfxY.value, -50, 150, c.y ?? 7);
          c.scale = clampNum(gfxScale.value, 0.25, 3, c.scale ?? 1);
          c.motion = String(gfxMotion.value || c.motion || "fade");

          // Image overlay extras (Phase 1): background layer + fit + opacity
          try{
            const ov = (c.overlay || overlayFromGfxClip(c));
            const isImg = (String(ov?.type || "") === OVERLAY_TYPES.IMAGE || String(ov?.type || "") === "image");
            if (isImg){
              const lay = String(gfxLayer?.value || ov?.layer || c.layer || "overlay");
              c.layer = (lay === "bg" || lay === "background") ? "bg" : "overlay";
              c.assetFit = String(gfxFit?.value || ov?.asset?.fit || c.assetFit || "contain");
              c.assetOpacity = clampNum(gfxOpacity?.value, 0, 1, (Number.isFinite(+ov?.asset?.opacity) ? +ov.asset.opacity : 1));
            }
          }catch(_e){}

          // For lower thirds, also sync text live.
          // For image overlays, text fields are ignored by render but harmless to keep.
          c.kicker = String(gfxKicker.value||c.kicker||"");
          c.title = String(gfxTitle.value||c.title||"");
          c.subtitle = String(gfxSub.value||c.subtitle||"");

          // Keep canonical overlay object synced (silent to avoid thrash)
          applyOverlayToGfxClip(c, overlayFromGfxClip(c), {silent:true});
          try{ __normalizeOverlayOrdering(true); }catch(_e){}

          updateCounts();
          buildRuler();
          renderTimeline();
          renderOverlays();
        }catch(_e){}
      }, delay);
    };
  })();

  // Wire live updates (numbers: immediate; text: slightly debounced)
  [gfxStart, gfxDur, gfxX, gfxY, gfxScale, gfxMotion, gfxLayer, gfxFit, gfxOpacity].forEach(inp => {
    try{ inp.addEventListener("input", () => __gfxLiveApply(30), {passive:true}); }catch(_e){}
    try{ inp.addEventListener("change", () => __gfxLiveApply(30), {passive:true}); }catch(_e){}
  });
  [gfxKicker, gfxTitle, gfxSub].forEach(inp => {
    try{ inp.addEventListener("input", () => __gfxLiveApply(160), {passive:true}); }catch(_e){}
    try{ inp.addEventListener("change", () => __gfxLiveApply(80), {passive:true}); }catch(_e){}
  });

  previewGfxBtn.addEventListener("click", () => {
    __pushUndo("Toggle GFX preview");
    gfxPreviewOn = !gfxPreviewOn;
    previewGfxState.textContent = gfxPreviewOn ? "On" : "Off";
    renderOverlays();
  });


  gfxEnabledBtn?.addEventListener("click", () => {
    const c = clips.find(x=>x.id===selectedClipId);
    if (!c || c.kind!=="gfx") return;
    __pushUndo("Toggle overlay enabled");

    const cur = (c.overlay?.enabled ?? c.enabled ?? true);
    const nextEnabled = !cur;

    const nextOv = ensureOverlaySchema(Object.assign({}, c.overlay || overlayFromGfxClip(c), { enabled: !!nextEnabled }));
    applyOverlayToGfxClip(c, nextOv);

    renderInspector();
    renderTimeline();
    renderOverlays();
    setStatus(nextEnabled ? "Overlay enabled (preview)." : "Overlay disabled (preview).");
  });

  gfxSoloBtn?.addEventListener("click", () => {
    const c = clips.find(x=>x.id===selectedClipId);
    if (!c || c.kind!=="gfx") return;
    __pushUndo("Toggle overlay solo");

    const cur = (c.overlay?.solo ?? c.solo ?? false);
    const nextSolo = !cur;

    const patch = { solo: !!nextSolo };
    if (nextSolo) patch.enabled = true; // solo implies visible
    const nextOv = ensureOverlaySchema(Object.assign({}, c.overlay || overlayFromGfxClip(c), patch));
    applyOverlayToGfxClip(c, nextOv);

    renderInspector();
    renderTimeline();
    renderOverlays();
    setStatus(nextSolo ? "Overlay soloed (preview only)." : "Overlay solo cleared (preview).");
  });
  // Presets (simple style switches)
  presetNews.addEventListener("click", () => setGfxPreset("news"));
  presetCine.addEventListener("click", () => setGfxPreset("cine"));
  presetMinimal.addEventListener("click", () => setGfxPreset("minimal"));

  function setGfxPreset(preset){
    const c = clips.find(x=>x.id===selectedClipId);
    if (!c || c.kind!=="gfx") return;
    __pushUndo("GFX preset");
    c.stylePreset = preset;
    if (preset === "news"){
      c.kicker = c.kicker || "WARCHIEF";
      c.title = c.title || "Breaking Update";
      c.subtitle = c.subtitle || "Lower third subtitle";
    } else if (preset === "cine"){
      c.kicker = c.kicker || "FEATURE";
      c.title = c.title || "Subject Name";
      c.subtitle = c.subtitle || "Cinematography / Location";
    } else {
      c.kicker = c.kicker || "NOTE";
      c.title = c.title || "Minimal Title";
      c.subtitle = c.subtitle || "";
    }
    
    // Phase A / Stage 1+2: keep canonical overlay contract synced and normalize ordering
    applyOverlayToGfxClip(c, overlayFromGfxClip(c));
    try{ __normalizeOverlayOrdering(); }catch(_e){}
renderInspector();
    renderOverlays();
    renderTimeline();
  }

  function clampNum(v, lo, hi, fallback){
    const n = Number(v);
    if (!isFinite(n)) return fallback;
    return Math.max(lo, Math.min(hi, n));
  }

  // Overlays renderer

  function __isBgGfxClip(c){
    try{
      if (!c || c.kind !== "gfx") return false;
      const o = (c.overlay || overlayFromGfxClip(c));
      const layer = String(o?.layer || c.layer || "overlay");
      return (layer === "bg" || layer === "background");
    }catch(_e){ return false; }
  }

  function renderBackgroundLayer(){
    if (!bgLayer) return;
    if (__overlayDragActive && __overlayDrag && __overlayDrag.container === bgLayer) return;

    try{ bgLayer.classList.remove("interactive"); }catch(_e){}
    bgLayer.innerHTML = "";

    if (!gfxPreviewOn) return;

    const t = playhead;
    const items = clips.filter(c => c.kind==="gfx" && t >= c.start && t <= (c.start + c.dur));
    if (!items.length) return;

    const visibleClips = getRenderableGfxClips(items);
    const bgClips = visibleClips.filter(__isBgGfxClip);
    if (!bgClips.length) return;

    const ordered = bgClips.slice().sort((a,b) => __overlayCompare(a.overlay || overlayFromGfxClip(a), b.overlay || overlayFromGfxClip(b)));
    const c = ordered[ordered.length - 1];
    const o = (c.overlay || overlayFromGfxClip(c));
    const ot = String(o?.type || "");
    if (ot !== OVERLAY_TYPES.IMAGE && ot !== "image") return;

        // Phase 2.3: Background layer is full-frame cover by default (Option A)
    // Preview matches export: background sits behind video and fills the frame.
    const el = document.createElement("div");
    el.className = "imgov bgimg";
    el.draggable = false;
    el.style.position = "absolute";
    el.style.left = "0";
    el.style.top = "0";
    el.style.right = "0";
    el.style.bottom = "0";
    el.style.width = "100%";
    el.style.height = "100%";
    el.style.transform = "none";
    el.style.pointerEvents = "none"; // background is not interactive in preview

    let url = "";
    try{
      const mid = o?.asset?.mediaId || c.mediaId || c.assetMediaId;
      if (mid){
        const mm = media.find(m => m.id === String(mid));
        url = String(mm?.url || "");
      }
    }catch(_e){}
    if (!url) url = String(o?.asset?.url || c.assetUrl || "");

    const name = String(o?.asset?.name || c.assetName || "");

    const img = document.createElement("img");
    img.className = "imgov-img";
    img.draggable = false;
    img.alt = name || "Background";
    if (url && __isProbablyRestorableUrl(url)) {
      img.src = url;
    } else {
      img.alt = "Missing image (reimport)";
      el.classList.add("missing");
    }

    // Full-frame cover
    img.style.width = "100%";
    img.style.height = "100%";
    img.style.objectFit = "cover";
    img.style.objectPosition = "center center";

    el.appendChild(img);

    const op = Number.isFinite(+o?.asset?.opacity) ? +o.asset.opacity : 1;
    el.style.opacity = String(Math.max(0, Math.min(1, op)));

    bgLayer.appendChild(el);
  }

  function renderOverlays(){
    if (__overlayDragActive) return;

    // Phase 1: render background graphics under the video first.
    try{ renderBackgroundLayer(); }catch(_e){}

    overlayLayer.classList.remove("interactive");
    overlayLayer.innerHTML = "";
    if (!gfxPreviewOn) return;

    const t = playhead;
    const itemsAll = clips.filter(c => c.kind==="gfx" && t >= c.start && t <= (c.start + c.dur));
    const items = itemsAll.filter(c => !__isBgGfxClip(c));
    if (!items.length) return;

    // Phase A / Stage 3: apply enabled/solo visibility rules (preview only)
    const visibleClips = getRenderableGfxClips(items);
    if (!visibleClips.length) return;

    // Phase A / Stage 2: choose top-most by deterministic overlay ordering (zIndex, start, id)
    const ordered = visibleClips.slice().sort((a,b) => __overlayCompare(a.overlay || overlayFromGfxClip(a), b.overlay || overlayFromGfxClip(b)));
    const c = ordered[ordered.length - 1];

    const o = (c.overlay || overlayFromGfxClip(c));
    const ot = String(o?.type || "");

    // Position + scale (percent-of-viewport)
    const x = (c.x ?? o?.transform?.xPct ?? 4.5);
    const y = (c.y ?? o?.transform?.yPct ?? 7);
    const sc = (c.scale ?? o?.transform?.scale ?? 1);

    // Motion presets (fade / slide) ‚Äî ‚Äúkeyframes-lite‚Äù
    const rel = t - c.start;
    const inDur = 0.25;
    const outDur = 0.25;
    const ease = (u) => {
      u = Math.max(0, Math.min(1, u));
      return u < 0.5 ? (2*u*u) : (1 - Math.pow(-2*u + 2, 2)/2);
    };

    let alpha = 1;
    let ty = 0;
    if ((c.motion || o?.motion?.preset || "fade") !== "none"){
      if (rel < inDur){
        alpha = ease(rel / inDur);
        if ((c.motion || o?.motion?.preset || "fade") === "slide") ty = (1 - alpha) * 18;
      } else if (rel > (c.dur - outDur)){
        const u = (c.dur - rel) / outDur;
        alpha = ease(u);
        if ((c.motion || o?.motion?.preset || "fade") === "slide") ty = (1 - alpha) * 18;
      }
    }

    let el;
    if (ot === "image"){
      // Image overlay (Phase 4A)
      el = document.createElement("div");
      el.className = "imgov";
      el.draggable = false;

      let url = "";
      try{
        const mid = o?.asset?.mediaId || c.mediaId || c.assetMediaId;
        if (mid){
          const mm = media.find(m => m.id === String(mid));
          url = String(mm?.url || "");
        }
      }catch(_e){}
      if (!url) url = String(o?.asset?.url || c.assetUrl || "");

      const name = String(o?.asset?.name || c.assetName || "");

      const img = document.createElement("img");
      img.className = "imgov-img";
      img.draggable = false;
      if (url && __isProbablyRestorableUrl(url)) { img.src = url; } else { img.removeAttribute('src'); img.alt = 'Missing image (reimport)'; el.classList.add('missing'); }
      img.alt = name;
      try{
        const fit = String(o?.asset?.fit || c.assetFit || "contain");
        img.style.objectFit = (fit === "cover") ? "cover" : "contain";
      }catch(_e){}
      el.appendChild(img);

      // Resize handle
      const h = document.createElement("div");
      h.className = "ov-handle";
      h.dataset.ovhandle = "scale";
      h.title = "Resize";
      el.appendChild(h);

      const op = Number.isFinite(+o?.asset?.opacity) ? +o.asset.opacity : 1;
      el.style.opacity = String(alpha * Math.max(0, Math.min(1, op)));
    } else {
      el = document.createElement("div");
      el.className = "lowerthird";
      el.style.opacity = String(alpha);

      // preset styling tweaks
      if (c.stylePreset === "cine"){
        el.style.borderColor = "rgba(129,140,248,.35)";
        el.style.background = "linear-gradient(135deg, rgba(2,6,23,.88), rgba(2,6,23,.46))";
      } else if (c.stylePreset === "minimal"){
        el.style.borderColor = "rgba(148,163,184,.24)";
        el.style.background = "rgba(2,6,23,.68)";
        el.style.backdropFilter = "blur(10px)";
      }

      el.innerHTML = `
        <div class="lt-kicker">${escapeHtml(c.kicker || "")}</div>
        <div class="lt-title">${escapeHtml(c.title || "")}</div>
        <div class="lt-sub">${escapeHtml(c.subtitle || "")}</div>
      `;

      // Resize handle
      const h = document.createElement("div");
      h.className = "ov-handle";
      h.dataset.ovhandle = "scale";
      h.title = "Resize";
      el.appendChild(h);
    }

    el.style.left = x + "%";
    el.style.bottom = y + "%";
    el.style.transformOrigin = "left bottom";
    el.style.transform = `translateY(${ty}px) scale(${sc})`;

    // Interactive: click/drag overlay in preview to reposition (Stage 5.1 hotfix)
    try{ if (selectedClipId === c.id) el.classList.add("selected"); }catch(_e){}
    try{ overlayLayer.classList.add("interactive"); }catch(_e){}
    el.addEventListener("pointerdown", (e) => __beginOverlayDrag(e, el, c), {passive:false});
    el.addEventListener("mousedown", (e) => __beginOverlayDrag(e, el, c), {passive:false});

    overlayLayer.appendChild(el);
  }


  // Preview: determine active video clip for time
  function getActiveVideoClip(t){
    // Find clip on V1 where t in [start, start+dur)
    const vclips = clips.filter(c => c.track==="v1" && c.kind==="video").sort((a,b)=>a.start-b.start);
    for (const c of vclips){
      if (t >= c.start && t < (c.start + c.dur)){
        return c;
      }
    }
    return null;
  }

  function syncActiveClipChip(){
    const c = getActiveVideoClip(playhead);
    if (!c){
      activeClipChip.textContent = "Active: ‚Äî";
      return;
    }
    const name = media.find(m=>m.id===c.mediaId)?.name || "Clip";
    activeClipChip.textContent = `Active: ${name}`;
  }

  // Video switching & seeking
  let currentVideoClipId = null;

  function seekPreviewTo(t){
    const c = getActiveVideoClip(t);
    if (!c){
      previewVideo.removeAttribute("src");
      previewVideo.load();
      currentVideoClipId = null;
      syncActiveClipChip();
      return;
    }
    const m = media.find(mm => mm.id === c.mediaId);
    if (!m){
      previewVideo.removeAttribute("src");
      previewVideo.load();
      currentVideoClipId = null;
      return;
    }

    const clipT = Math.max(0, (t - c.start) + (c.in||0));
    // swap if needed
    if (currentVideoClipId !== c.id){
      currentVideoClipId = c.id;
      previewVideo.src = m.url;
      previewVideo.muted = masterMuted || !!c.clipAudioMuted;
      previewVideo.currentTime = clipT;
      // If we're paused, nudge a frame render without leaving it playing.
      if (!isPlaying){
        try{ previewVideo.pause(); }catch(e){}
        // Some browsers only paint the first frame after a brief play/pause tick.
        previewVideo.play().then(() => previewVideo.pause()).catch(()=>{});
      }
    } else {
      try{ previewVideo.currentTime = clipT; }catch(e){}
      previewVideo.muted = masterMuted || !!c.clipAudioMuted;
    }

    syncActiveClipChip();
  }

  function startPreviewAt(t){
    seekPreviewTo(t);
    if (!isPlaying) return;
    // try to play video (will fail if user gesture not present)
    previewVideo.play().catch(()=>{});
    startAudioAt(t);
  }

  // Transport controls
  playBtn.addEventListener("click", togglePlay);
  stopBtn.addEventListener("click", stop);
  stepBack.addEventListener("click", () => step(-1));
  stepFwd.addEventListener("click", () => step(1));

  function step(dir){
    const fps = Number(fpsSelect.value)||30;
    const dt = 1 / fps;
    setPlayhead(playhead + dir * dt);
  }

  function togglePlay(){
    if (isPlaying) pause();
    else play();
  }

  function play(){
    if (isPlaying) return;
    isPlaying = true;
    playBtn.textContent = "‚ùö‚ùö";
    lastPerf = performance.now();
    setStatus("Playing‚Ä¶");
    startPreviewAt(playhead);
    raf = requestAnimationFrame(tick);
  }

  function pause(){
    if (!isPlaying) return;
    isPlaying = false;
    playBtn.textContent = "‚ñ∂";
    setStatus("Paused.");
    cancelAnimationFrame(raf);
    raf = 0;
    previewVideo.pause();
    stopAudio();
  }

  function stop(){
    pause();
    setPlayhead(0);
    setStatus("Stopped.");
  }

  function tick(now){
    if (!isPlaying) return;
    const dt = Math.min(0.05, (now - lastPerf)/1000);
    lastPerf = now;

    playhead += dt;
    const len = getTimelineLength();
    if (len > 0 && playhead >= len){
      stop();
      return;
    }

    playheadSecLabel.textContent = playhead.toFixed(2);
    timeReadout.textContent = fmtTime(playhead);
    updatePlayheadEl();
    ensurePlayheadVisible();
    renderOverlays();

    // keep preview aligned (lightweight switching)
    const active = getActiveVideoClip(playhead);
    if (!active){
      previewVideo.pause();
      currentVideoClipId = null;
      syncActiveClipChip();
    } else {
      const m = media.find(mm => mm.id === active.mediaId);
      if (m){
        const clipT = Math.max(0, (playhead - active.start) + (active.in||0));
        if (currentVideoClipId !== active.id){
          currentVideoClipId = active.id;
          previewVideo.src = m.url;
          previewVideo.muted = masterMuted || !!active.clipAudioMuted;
          previewVideo.currentTime = clipT;
          previewVideo.play().catch(()=>{});
          stopAudio(); // reset audio scheduling on clip switch
          startAudioAt(playhead);
        } else {
          // nudge if drift is large
          const drift = Math.abs((previewVideo.currentTime||0) - clipT);
          if (drift > 0.20){
            try{ previewVideo.currentTime = clipT; }catch(e){}
          }
          previewVideo.muted = masterMuted || !!active.clipAudioMuted;
        }
        syncActiveClipChip();
      }
    }

    raf = requestAnimationFrame(tick);
  }

  // Audio (WebAudio): schedule imported audio clips against the timeline
  async function ensureAudio(){
    if (!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      audioGain = audioCtx.createGain();
      audioGain.gain.value = 0.9;
      audioGain.connect(audioCtx.destination);
    }
    if (audioCtx.state === "suspended"){
      try{ await audioCtx.resume(); }catch(e){}
    }
  }

  async function decodeAudio(mediaId){
    const m = media.find(x => x.id === mediaId);
    if (!m) return null;
    if (m._buf) return m._buf;
    try{
      const ab = await m.file.arrayBuffer();
      await ensureAudio();
      const buf = await audioCtx.decodeAudioData(ab.slice(0));
      m._buf = buf;
      m.duration = m.duration || buf.duration || 0;
      return buf;
    }catch(e){
      return null;
    }
  }

  async function startAudioAt(t){
    // If master is clip audio only, do nothing (video audio handles it).
    if ($("#audioMaster").value !== "webaudio") return;

    await ensureAudio();
    stopAudio();

    const now = audioCtx.currentTime;
    const aclips = clips.filter(c => c.track==="a1" && c.kind==="audio");

    for (const c of aclips){
      const m = media.find(mm => mm.id === c.mediaId);
      if (!m) continue;

      const buf = await decodeAudio(c.mediaId);
      if (!buf) continue;

      const clipStart = c.start;
      const clipEnd = c.start + c.dur;

      if (t >= clipEnd) continue; // already past
      const startDelay = Math.max(0, clipStart - t); // seconds from now to start
      const offset = Math.max(0, t - clipStart); // how far into the clip we are

      const src = audioCtx.createBufferSource();
      src.buffer = buf;
      src.connect(audioGain);

      const when = now + startDelay;
      const startOffset = Math.min(buf.duration - 0.01, (c.in||0) + offset);
      const playFor = Math.max(0.01, Math.min(c.dur - offset, (c.out||c.dur) - (c.in||0) - offset, buf.duration - startOffset));

      try{
        src.start(when, startOffset, playFor);
        audioSources.push({clipId:c.id, srcNode:src, startedAtCtxTime:when, offsetSec:startOffset});
      }catch(e){}
    }
  }

  function stopAudio(){
    for (const s of audioSources){
      try{ s.srcNode.stop(); }catch(e){}
    }
    audioSources = [];
  }

  // Snap toggle
  snapBtn.addEventListener("click", () => {
    __pushUndo("Toggle snap");
    snapOn = !snapOn;
    snapState.textContent = snapOn ? "On" : "Off";
    __updateUndoRedoButtons();
  });

  // Ripple toggle (v1)
  rippleBtn.addEventListener("click", () => {
    __pushUndo("Toggle ripple");
    rippleOn = !rippleOn;
    rippleState.textContent = rippleOn ? "On" : "Off";
    __updateUndoRedoButtons();
  });

  // Undo/Redo buttons
  undoBtn.addEventListener("click", undo);
  redoBtn.addEventListener("click", redo);

  // Split (mock): only works for V1/A1 clips
  splitBtn.addEventListener("click", () => {
    const c = clips.find(x=>x.id===selectedClipId);
    if (!c || c.kind==="gfx") { setStatus("Split works on video/audio clips (mock)."); return; }
    const t = playhead;
    if (t <= c.start + 0.05 || t >= c.start + c.dur - 0.05){
      setStatus("Split: playhead must be inside the selected clip.");
      return;
    }
    __pushUndo("Split clip");
    const leftDur = t - c.start;
    const rightDur = (c.start + c.dur) - t;

    // left clip becomes original
    const oldDur = c.dur;
    c.dur = leftDur;
    c.out = (c.in||0) + leftDur;

    // new right clip
    const newClip = addClip({
      track: c.track,
      kind: c.kind,
      mediaId: c.mediaId,
      start: t,
      dur: rightDur,
      in: (c.in||0) + leftDur,
      out: (c.in||0) + oldDur,
      clipAudioMuted: c.clipAudioMuted
    });

    selectClip(newClip.id);
    updateCounts();
    buildRuler();
    renderTimeline();
    renderOverlays();
    setStatus("Split clip at playhead (mock).");
  });

  deleteBtn.addEventListener("click", () => {
    if (!selectedClipId) return;
    const idx = clips.findIndex(c=>c.id===selectedClipId);
    if (idx >= 0){
      __pushUndo("Delete clip");
      const wasGfx = clips[idx].kind === "gfx";
      clips.splice(idx, 1);
      selectedClipId = null;
      updateCounts();
      buildRuler();
      renderTimeline();
      if (wasGfx) renderOverlays();
      renderInspector();
      setStatus("Deleted clip.");
    }
  });

  // Safe guides
  toggleSafeBtn.addEventListener("click", () => {
    const on = safeGuide.style.display === "block";
    safeGuide.style.display = on ? "none" : "block";
  });

  // Help modal wiring (Phase 2.5+) handled via #helpModalBackdrop

  // Export modal
  exportBtn.addEventListener("click", () => openModal(exportModal));
  exportClose.addEventListener("click", () => closeModal(exportModal));
  exportOk.addEventListener("click", () => closeModal(exportModal));



  /* ==========================================================
     Phase A ‚Äî Overlay Core Schema & Serialization
     Stage 4: Deterministic .warcut Serialization + Reload Helpers
     Goals:
       - Export payload order is deterministic (sorted arrays + stable key order)
       - GFX overlays serialize as first-class overlay objects (schema v1)
       - Reload path can re-hydrate clips/overlays in-session for verification
     Notes:
       - No timestamps in export payload (keeps exports byte-stable)
       - Media blobs are NOT embedded; reload works best within the same session
  ========================================================== */

  const WARCUT_SCHEMA_VERSION = 1;

  function __trackRank(track){
    const t = String(track || "");
    if (t === "v1") return 0;
    if (t === "gfx") return 1;
    if (t === "a1") return 2;
    return 99;
  }

  function __compareTimelineClips(a,b){
    const ra = __trackRank(a?.track);
    const rb = __trackRank(b?.track);
    if (ra !== rb) return ra - rb;
    const sa = +a?.start || 0;
    const sb = +b?.start || 0;
    if (sa !== sb) return sa - sb;
    const da = +a?.dur || 0;
    const db = +b?.dur || 0;
    if (da !== db) return da - db;
    const ia = String(a?.id || "");
    const ib = String(b?.id || "");
    return ia.localeCompare(ib);
  }

  function __canonicalMediaItem(m){
    // Keep key order stable by constructing explicitly
    return {
      id: String(m?.id || ""),
      kind: String(m?.kind || ""),
      name: String(m?.name || ""),
      type: String(m?.file?.type || m?.type || ""),
      size: Number(m?.file?.size || m?.size || 0),
      duration: Number(m?.duration || 0),
      w: Number(m?.w || 0),
      h: Number(m?.h || 0)
    };
  }

  function __canonicalTimelineItem(c){
    const base = {
      id: String(c?.id || uid()),
      track: String(c?.track || "v1"),
      kind: String(c?.kind || "video"),
      mediaId: c?.mediaId ? String(c.mediaId) : null,
      start: Number(c?.start || 0),
      dur: Number(c?.dur || 0),
      in: Number(c?.in || 0),
      out: Number((c?.out ?? (c?.dur || 0)) || 0),
      clipAudioMuted: !!c?.clipAudioMuted
    };

    if (base.kind === "gfx"){
      // Reference overlay by id (overlay objects live in payload.overlays)
      const ov = ensureOverlaySchema(c?.overlay || overlayFromGfxClip(c));
      base.mediaId = null; // gfx has no mediaId
      base.overlayId = String(ov.id);
      // Keep some legacy fields for backwards compatibility / quick inspection
      base.kicker = String(c?.kicker || ov?.text?.kicker || "");
      base.title  = String(c?.title  || ov?.text?.title  || "");
      base.subtitle = String(c?.subtitle || ov?.text?.subtitle || "");
      base.stylePreset = String(c?.stylePreset || ov?.style?.preset || "news");
      base.enabled = !!ov.enabled;
      base.solo = !!ov.solo;
      base.zIndex = Number(ov.zIndex || 0);
    } else {
      // Lower-third fields exist on clips in the mockup, keep them stable
      base.kicker = String(c?.kicker || "");
      base.title  = String(c?.title  || "");
      base.subtitle = String(c?.subtitle || "");
      base.stylePreset = String(c?.stylePreset || "news");
    }

    return base;
  }

  function __buildWarcutPayload(){
    // Enforce z-index normalization rules before export
    try{ __normalizeOverlayOrdering(); }catch(_e){}

    const fps = Number(fpsSelect.value) || 30;
    const name = String(projectName.textContent || "Untitled.warcut");

    // Canonical overlay list (first-class objects)
    const overlays = clips
      .filter(c => c && c.kind === "gfx")
      .map(c => ensureOverlaySchema(c.overlay || overlayFromGfxClip(c)))
      .sort(__overlayCompare);

    // Deterministic media ordering (by id; stable within-session)
    const mediaOut = media
      .slice()
      .map(__canonicalMediaItem)
      .sort((a,b) => String(a.id).localeCompare(String(b.id)));

    // Deterministic timeline ordering
    const timelineOut = clips
      .slice()
      .map(__canonicalTimelineItem)
      .sort(__compareTimelineClips);

    // Keep top-level keys in a stable order by constructing explicitly
    return {
      app: "Warcut Studio",
      fileType: "warcut",
      schemaVersion: WARCUT_SCHEMA_VERSION,
      version: "mockup-v0A",
      project: { name, fps },
      media: mediaOut,
      timeline: timelineOut,
      overlays
    };
  }

  function __stringifyWarcutPayload(payload){
    // Phase A / Stage 4+5: deterministic JSON ordering for stable exports & diffs.
    return __stableStringify(payload, { space: 2 });
  }

  function __suggestProjectFilename(base){
    const raw = String(base || "warcut").trim() || "warcut";
    const safe = raw.replace(/[\\\/:*?"<>|]+/g, "_");
    if (safe.toLowerCase().endsWith(".warcut")) return safe;
    if (safe.toLowerCase().endsWith(".json")) return safe;
    return safe + ".warcut";
  }

  function __loadWarcutPayload(payload){
    if (!payload || typeof payload !== "object") throw new Error("Invalid payload");
    const p = payload.project || {};
    if (p.name != null) projectName.textContent = String(p.name);
    if (p.fps != null) fpsSelect.value = String(Number(p.fps) || 30);

    // Media: best-effort rehydrate (works best in same session)
    const existingById = new Map(media.map(m => [m.id, m]));
    const nextMedia = [];
    const mediaList = Array.isArray(payload.media) ? payload.media : [];
    for (const mi of mediaList){
      const id = String(mi?.id || "");
      if (!id) continue;
      const live = existingById.get(id);
      if (live){
        nextMedia.push(live);
      } else {
        nextMedia.push({
          id,
          kind: String(mi?.kind || ""),
          name: String(mi?.name || ""),
          file: null,
          url: null,
          duration: Number(mi?.duration || 0),
          w: Number(mi?.w || 0),
          h: Number(mi?.h || 0),
          __missing: true
        });
      }
    }
    media = nextMedia;
    selectedMediaId = media[0]?.id || null;

    // Overlays map (first-class)
    const overlayById = new Map();
    const ovs = Array.isArray(payload.overlays) ? payload.overlays : [];
    for (const o of ovs){
      try{
        const ov = ensureOverlaySchema(o);
        try{
          const au = String(ov?.asset?.url || "");
          if (au.startsWith("blob:") && !__SESSION_BLOB_URLS.has(au)){
            // stale blob URL from prior session; cannot be restored
            if (ov.asset) ov.asset.url = null;
            ov.__missingAsset = true;
          }
        }catch(_e){}

        overlayById.set(String(ov.id), ov);
      }catch(_e){}
    }

    // Timeline
    clips = [];
    const tl = Array.isArray(payload.timeline) ? payload.timeline : [];
    for (const item of tl){
      const kind = String(item?.kind || "video");
      const track = String(item?.track || (kind === "audio" ? "a1" : (kind === "gfx" ? "gfx" : "v1")));

      const base = {
        id: String(item?.id || uid()),
        track,
        kind,
        mediaId: item?.mediaId ? String(item.mediaId) : null,
        start: Number(item?.start || 0),
        dur: Number(item?.dur || 0),
        in: Number(item?.in || 0),
        out: Number((item?.out ?? item?.dur) || 0),
        kicker: String(item?.kicker || ""),
        title: String(item?.title || ""),
        subtitle: String(item?.subtitle || ""),
        stylePreset: String(item?.stylePreset || "news"),
        clipAudioMuted: !!item?.clipAudioMuted
      };

      if (kind === "gfx"){
        const oid = String(item?.overlayId || item?.id || "");
        const ov = overlayById.get(oid) || overlayById.get(String(item?.id || "")) || item?.overlay || null;
        if (ov){
          try{ base.overlay = ensureOverlaySchema(ov); }catch(_e){}
        }
        try{
          applyOverlayToGfxClip(base, base.overlay ? ensureOverlaySchema(base.overlay) : overlayFromGfxClip(base));
        }catch(_e){}
        base.enabled = !!(base.overlay?.enabled);
        base.solo = !!(base.overlay?.solo);
      }

      addClip(base);
    }

    // Final normalize + redraw
    try{ __normalizeOverlayOrdering(); }catch(_e){}
    try{ updateBin(); }catch(_e){}
    try{ updateCounts(); }catch(_e){}
    try{ renderTimeline(); }catch(_e){}
    try{ renderOverlays(); }catch(_e){}
    try{ updateInspector(); }catch(_e){}
    setStatus("Loaded project JSON into current session (best-effort).");
  }

  // DevTools exposure
  try{
    if (window.__warcutDebug){
      window.__warcutDebug.buildWarcutPayload = () => __buildWarcutPayload();
      window.__warcutDebug.exportWarcutJSON = () => __stringifyWarcutPayload(__buildWarcutPayload());
      window.__warcutDebug.loadWarcutPayload = (p) => __loadWarcutPayload(p);
      window.__warcutDebug.loadWarcutJSON = (s) => __loadWarcutPayload(JSON.parse(String(s)));
      window.__warcutDebug.normalizeOverlayZ = () => { __normalizeOverlayOrdering(); renderTimeline(); renderOverlays(); return true; };
      window.__warcutDebug.suggestFilename = (n) => __suggestProjectFilename(n);
      // Phase A / Stage 5 helpers
      window.__warcutDebug.commitOverlayCore = (r) => { __commitOverlayCore(String(r||"manual")); return __overlayHealthCheck(); };
      window.__warcutDebug.healthCheck = () => __overlayHealthCheck();
      window.__warcutDebug.autosaveNow = () => { __autosaveNow("manual"); return true; };
      window.__warcutDebug.hasAutosave = () => !!localStorage.getItem(__AUTOSAVE_KEY);
      window.__warcutDebug.clearAutosave = () => __clearAutosave();
      window.__warcutDebug.setOverlays = (arr, r) => __setOverlays(arr, r);

      // Phase B / Stage 1 rasterizer hooks
      window.__warcutDebug.rasterLowerThirdBytes = (item, w=1280, h=720) => __warcutRaster.lowerThirdToPngBytes(item, w, h);
      window.__warcutDebug.downloadRasterLowerThird = async (item, w=1280, h=720, name="lower_third.png") => {
        const bytes = await __warcutRaster.lowerThirdToPngBytes(item, w, h);
        const blob = new Blob([bytes.buffer], { type: "image/png" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = String(name || "lower_third.png");
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 1200);
        return true;
      };

    }
  }catch(_e){}

  // Download helper (used by export buttons)

  // --- Shared numeric guard (used across export + gfx mapping) ---
  const safeNum = (v, d=0) => (Number.isFinite(+v) ? +v : d);

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename || "download";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }


  exportJsonBtn.addEventListener("click", () => {
    const payload = __buildWarcutPayload();
    const json = __stringifyWarcutPayload(payload);
    const fname = __suggestProjectFilename(projectName.textContent || "warcut");
    downloadBlob(new Blob([json], {type:"application/json"}), fname);
  });

  importProjectJsonBtn.addEventListener("click", () => {
    projectInput.value = "";
    projectInput.click();
  });

  projectInput.addEventListener("change", async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    try{
      const text = await f.text();
      const payload = JSON.parse(text);
      __loadWarcutPayload(payload);
    }catch(err){
      console.error(err);
      setStatus("Could not load project JSON (see console).");
    }
  });


  exportFrameBtn.addEventListener("click", async () => {
    const t = playhead;

    // Ensure we have an active video clip at the playhead
    const vc = clips
      .filter(c => c.kind === "video" && t >= c.start && t <= (c.start + c.dur))
      .sort((a,b)=>a.start-b.start)
      .pop();

    if (!vc){
      setStatus("No active video clip at the playhead.");
      return;
    }

    // Seek preview to the current playhead (so previewVideo has the right frame)
    seekPreviewTo(t);
    await new Promise((resolve) => {
      const done = () => resolve();
      if (previewVideo.readyState >= 2) {
        // wait one microtask to let the seek land
        requestAnimationFrame(done);
      } else {
        previewVideo.addEventListener("loadeddata", done, { once:true });
      }
    });

    const w = previewVideo.videoWidth || 1280;
    const h = previewVideo.videoHeight || 720;

    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d");

    // Draw video frame
    try{
      ctx.drawImage(previewVideo, 0, 0, w, h);
    }catch(_e){
      setStatus("Could not capture the current frame (browser limitation).");
      return;
    }

    // Draw overlays (Phase B rasterizer) using the unified renderOverlayFrame() path
    if (gfxPreviewOn){
      const activeGfx = clips.filter(c => c.kind === "gfx" && t >= c.start && t <= (c.start + c.dur));
      const renderableClips = getRenderableGfxClips(activeGfx).slice().sort((a,b)=>__overlayCompare(a.overlay, b.overlay));
      const ovs = renderableClips.map(gc => ensureOverlaySchema(gc.overlay || overlayFromGfxClip(gc)));

      // Ensure fonts/images are ready before the synchronous raster pass.
      await ensureOverlayAssetsReady(ovs);

      const ocanvas = renderOverlayFrame({ t, overlays: ovs, targetW: w, targetH: h, safeAreaPreset: "none", bg: null });
      ctx.drawImage(ocanvas, 0, 0, w, h);
    }

    canvas.toBlob((blob) => {
      if (!blob){
        setStatus("Could not export frame.");
        return;
      }
      const name = (projectName.textContent||"warcut") + "_frame_" + Math.round(t*1000) + "ms.png";
      downloadBlob(blob, name);
      setStatus("Exported frame: " + name);
    }, "image/png");
  });


  
  
  // ==========================================================
  // Phase B Stage 5: Export Probe Strip (debug-only UI)
  // - Renders 8‚Äì10 overlay frames around playhead
  // - Uses PhaseB rasterizeOverlaysToPngFramesV2 (same pixels as export harness)
  // - Clicking a thumbnail downloads the PNG
  // ==========================================================

  async function __probeOverlayFramesToStrip({
    centerT=0,
    fps=30,
    count=10,
    targetW=640,
    targetH=360,
    safeAreaPreset="none",
    bg=null,
    overlays=null,
    stripEl=null,
    statusEl=null
  } = {}){
    const PhaseB = window.__warcutPhaseB;
    if (!PhaseB || typeof PhaseB.rasterizeOverlaysToPngFramesV2 !== "function"){
      throw new Error("PhaseB rasterizer missing (rasterizeOverlaysToPngFramesV2)");
    }

    const ovs = Array.isArray(overlays) ? overlays : [];
    fps = Math.max(1, Number(fps)||30);
    count = Math.max(3, Math.min(20, Number(count)||10));

    // Centered time window: count frames at fps
    const half = (count-1) / (2*fps);
    const start = Math.max(0, Number(centerT||0) - half);
    const end = start + (count-1)/fps;

    if (stripEl) stripEl.innerHTML = "";
    if (statusEl) statusEl.textContent = `Probe: preparing (${count} frames @ ${fps}fps)‚Ä¶`;

    // Ensure assets/fonts ready if available
    try{
      if (typeof window.ensureOverlayAssetsReady === "function"){
        await window.ensureOverlayAssetsReady(ovs);
      } else if (typeof window.__warcutDebug?.ensureOverlayAssetsReady === "function"){
        await window.__warcutDebug.ensureOverlayAssetsReady(ovs);
      } else if (typeof PhaseB.ensureOverlayAssetsReady === "function"){
        await PhaseB.ensureOverlayAssetsReady(ovs);
      }
    }catch(_e){ /* non-fatal */ }

    const gen = PhaseB.rasterizeOverlaysToPngFramesV2({
      fps, start, end, targetW, targetH, safeAreaPreset, bg, overlays: ovs,
      useSchedule: false // probe window may not start at 0; keep simple & deterministic
    });

    let i = 0;
    for await (const f of gen){
      i++;
      if (statusEl) statusEl.textContent = `Probe: ${i}/${count} (dirty=${!!f.dirty}, reused=${!!f.reused})`;

      if (stripEl){
        const url = URL.createObjectURL(f.blob);
        const img = document.createElement("img");
        img.src = url;
        img.title = `i=${f.i} t=${Number(f.t).toFixed(3)}s dirty=${!!f.dirty} reused=${!!f.reused}`;
        img.addEventListener("click", () => {
          const name = (projectName?.textContent || "warcut") + `_overlay_${String(f.i).padStart(6,"0")}_${Math.round(f.t*1000)}ms.png`;
          downloadBlob(f.blob, name);
        });
        stripEl.appendChild(img);
      }

      // Let UI breathe
      await new Promise(requestAnimationFrame);
      if (i >= count) break;
    }

    if (statusEl) statusEl.textContent = `Probe: done (${count} frames). Click a thumbnail to download.`;
    return { start, end, fps, count };
  }

  // UI wiring (safe / optional)
  if (exportProbeClearBtn){
    exportProbeClearBtn.addEventListener("click", () => {
      if (exportProbeStrip) exportProbeStrip.innerHTML = "";
      if (exportProbeStatus) exportProbeStatus.textContent = "Probe: cleared";
    });
  }

  if (exportProbeBtn){
    exportProbeBtn.addEventListener("click", async () => {
      try{
        exportProbeBtn.disabled = true;
        const overlays = window.__warcutDebug?.project?.overlays || window.__warcutPhaseB?.project?.overlays || window.__warcutProject?.overlays || [];
        const fps = Number(fpsSelect?.value) || 30;
        const centerT = Number(playhead) || 0;

        await __probeOverlayFramesToStrip({
          centerT,
          fps,
          count: 10,
          targetW: 640,
          targetH: 360,
          overlays,
          stripEl: exportProbeStrip,
          statusEl: exportProbeStatus
        });
      }catch(err){
        console.error(err);
        if (exportProbeStatus) exportProbeStatus.textContent = "Probe: error (see console)";
      }finally{
        exportProbeBtn.disabled = false;
      }
    });
  }

  // DevTools convenience (does not affect app runtime)
  try{
    window.__warcutPhaseB = window.__warcutPhaseB || {};
    window.__warcutPhaseB.probeOverlayFramesToStrip = __probeOverlayFramesToStrip;
    window.__warcutDebug = window.__warcutDebug || {};
    window.__warcutDebug.probeOverlayFramesToStrip = __probeOverlayFramesToStrip;
  }catch(_e){}



function __buildExportCtx(m){
    // Find the first V1 video clip that references this media item (best-effort).
    const v1 = clips
      .filter(c => c && c.kind==="video" && c.mediaId===m.id && c.track==="v1")
      .sort((a,b)=> (a.start||0) - (b.start||0))[0];

    // Timeline base is the V1 clip's timeline start; gfx start times are relative to that.
    const timelineBase = v1 ? (+v1.start || 0) : 0;

    // Source in-point / duration (trim) if available; otherwise export the full media.
    const srcIn = v1 ? (+v1.in || 0) : 0;
    const dur = v1 ? (+v1.dur || 0) : (+m.duration || 0);

    // Collect all gfx clips (Lower Thirds) with Phase A visibility rules
    const gfxClips = clips
      .filter(c => c && c.kind==="gfx" && c.track==="gfx");

    // Ensure overlays exist and are normalized before export
    for (const c of gfxClips){
      try{ applyOverlayToGfxClip(c, c.overlay ? ensureOverlaySchema(c.overlay) : overlayFromGfxClip(c)); }catch(_e){}
    }
    try{ __normalizeOverlayOrdering(); }catch(_e){}

    // Enabled filter always applies. Solo behaves like preview (if any enabled+solo exists, only those export).
    const anySolo = gfxClips.some(c => c?.overlay?.enabled && c?.overlay?.solo);

    const gfx = gfxClips
      .filter(c => (c?.overlay?.enabled !== false))
      .filter(c => !anySolo || !!c?.overlay?.solo)
      .map(c => {
        const ov = ensureOverlaySchema(c.overlay || overlayFromGfxClip(c));
        return {
          id: String(ov.id),
          start: Number(c.start || ov?.timing?.start || 0),
          dur: Number(c.dur || ov?.timing?.dur || 0),
          zIndex: Number(ov.zIndex || 0),
          x: safeNum(ov?.transform?.xPct, safeNum(c.x, 4.5)),
          y: safeNum(ov?.transform?.yPct, safeNum(c.y, 7)),
          scale: safeNum(ov?.transform?.scale, safeNum(c.scale, 1)),
          stylePreset: String(ov?.style?.preset ?? c.stylePreset ?? "news"),
          kicker: String(ov?.style?.kicker ?? c.kicker ?? ""),
          title: String(ov?.style?.title ?? c.title ?? ""),
          subtitle: String(ov?.style?.subtitle ?? c.subtitle ?? ""),
        };
      })
      // Keep only ones that overlap the export window at all
      .filter(g => (g.start + g.dur) > timelineBase)
      // Deterministic overlay stack order (lower z first so higher z overlays on top)
      .sort((a,b) => (Number(a.zIndex||0) - Number(b.zIndex||0)) || String(a.id).localeCompare(String(b.id)));
    return {
      w: +m.w || 1920,
      h: +m.h || 1080,
      srcIn,
      dur,
      timelineBase,
      gfx
    };
  }

  // -----------------------------
  // Phase 2.2 ‚Äî Timeline ‚Üí MP4 core
  // Renders what is in the timeline (V1 video clips + A1 audio clips + GFX overlays),
  // with A1 replacing video audio when present.
  // -----------------------------

  function __isBgLayer(layer){
    const l = String(layer || "").toLowerCase().trim();
    return l === "bg" || l === "background";
  }

  function __extFromBlobType(t){
    const s = String(t||"").toLowerCase();
    if (s.includes("mp4")) return "mp4";
    if (s.includes("webm")) return "webm";
    if (s.includes("ogg")) return "ogg";
    if (s.includes("mpeg")) return "mp3";
    if (s.includes("mp3")) return "mp3";
    if (s.includes("wav")) return "wav";
    if (s.includes("aac")) return "aac";
    if (s.includes("m4a") || s.includes("mp4a")) return "m4a";
    if (s.includes("png")) return "png";
    if (s.includes("jpeg")) return "jpg";
    if (s.includes("jpg")) return "jpg";
    return "bin";
  }

  function __even(n){ n = Math.floor(Number(n)||0); return (n % 2) ? (n-1) : n; }

  async function __clipToOverlayPngBytes(clip, W, H){
    // Rasterizes a single GFX clip to a full-frame transparent PNG using Phase B renderer.
    const ov = ensureOverlaySchema(overlayFromGfxClip(clip));
    try{ await ensureOverlayAssetsReady([ov]); }catch(_e){}
    const t = (Number(ov?.timing?.start ?? clip?.start ?? 0) + Math.min(0.001, Math.max(0.0001, (Number(ov?.timing?.dur ?? clip?.dur ?? 0.25) * 0.5))));
    const canvas = renderOverlayFrame({ t, overlays:[ov], targetW: W, targetH: H, bg: null });
    const blob = await __B_canvasToPngBlob(canvas);
    return await __fetchFile(blob);
  }

  async function __clipToBgCoverPngBytes(bgClip, W, H){
    // Full-frame cover render (default behavior for BG layer).
    const ov = ensureOverlaySchema(overlayFromGfxClip(bgClip));
    const url = String(ov?.asset?.url || "");
    const img = await loadImage(url);
    if (!img) throw new Error("Background image asset not available (re-import PNG).");
    const canvas = document.createElement("canvas");
    canvas.width = W; canvas.height = H;
    const ctx = canvas.getContext("2d");

    const iw = (img.naturalWidth || img.width || 1);
    const ih = (img.naturalHeight || img.height || 1);
    const s = Math.max(W/iw, H/ih);
    const dw = iw * s;
    const dh = ih * s;
    const dx = (W - dw) / 2;
    const dy = (H - dh) / 2;
    ctx.drawImage(img, dx, dy, dw, dh);

    const blob = await __B_canvasToPngBlob(canvas);
    return await __fetchFile(blob);
  }

  async function exportTimelineToMp4(onLog){
    const ffmpeg = await __ensureFFmpeg(onLog);

    // Gather timeline items
    const vClips = clips.filter(c => c && c.kind==="video" && c.track==="v1").sort((a,b)=> (a.start||0)-(b.start||0));
    const aClips = clips.filter(c => c && c.kind==="audio" && c.track==="a1").sort((a,b)=> (a.start||0)-(b.start||0));
    const gfxAll = clips.filter(c => c && c.kind==="gfx" && c.track==="gfx");

    // Normalize overlays (enabled/solo + ordering) exactly like preview
    for (const c of gfxAll){
      try{ applyOverlayToGfxClip(c, c.overlay ? ensureOverlaySchema(c.overlay) : overlayFromGfxClip(c)); }catch(_e){}
    }
    try{ __normalizeOverlayOrdering(); }catch(_e){}
    const anySolo = gfxAll.some(c => c?.overlay?.enabled && c?.overlay?.solo);
    const gfxClips = gfxAll
      .filter(c => (c?.overlay?.enabled !== false))
      .filter(c => !anySolo || !!c?.overlay?.solo)
      .sort((a,b)=> (Number(a?.overlay?.zIndex||0) - Number(b?.overlay?.zIndex||0)) || String(a.id).localeCompare(String(b.id)));

    // Export duration = max end time across V1/A1/GFX
    const endT = (arr) => arr.reduce((mx,c)=> Math.max(mx, (Number(c?.start)||0) + (Number(c?.dur)||0)), 0);
    const exportDur = Math.max(0, endT(vClips), endT(aClips), endT(gfxClips));
    if (!(exportDur > 0)){
      throw new Error("Nothing on the timeline to export.");
    }

    // Determine export resolution (clamp max width 1280)
    let baseW = 1280, baseH = 720;
    if (vClips.length){
      const m = media.find(mm => mm.id === vClips[0].mediaId);
      const mw = Number(m?.w || 0);
      const mh = Number(m?.h || 0);
      if (mw > 0 && mh > 0){
        const maxW = 1280;
        const s = Math.min(1, maxW / mw);
        baseW = __even(mw * s);
        baseH = __even(mh * s);
        if (baseW < 320) baseW = 320;
        if (baseH < 240) baseH = 240;
      }
    }
    baseW = __even(baseW); baseH = __even(baseH);

    const fps = 30;

    // Cleanup previous run files (best-effort)
    const outputName = "timeline.mp4";
    try{ await ffmpeg.deleteFile(outputName); }catch(_e){}

    // Helper to write a fetched blob to FS
    async function __writeBlobToFs(name, blob){
      await ffmpeg.writeFile(name, await __fetchFile(blob));
      return name;
    }

    // Build ffmpeg inputs
    const args = ["-hide_banner","-y",
      "-f","lavfi","-i", `color=c=black:s=${baseW}x${baseH}:d=${exportDur}:r=${fps}`
    ];

    const inputs = []; // {kind, idx, start, dur, in, name}
    let idx = 1;

    // Background PNG clips (layer bg/background + type image)
    const bgGfx = gfxClips.filter(c => {
      try{
        const ov = ensureOverlaySchema(overlayFromGfxClip(c));
        return (String(ov.type)==="image" || ov.type===OVERLAY_TYPES.IMAGE) && __isBgLayer(ov.layer);
      }catch(_e){ return false; }
    });

    for (let i=0;i<bgGfx.length;i++){
      const c = bgGfx[i];
      const start = Math.max(0, Number(c.start||0));
      const dur = Math.max(0.001, Number(c.dur||0));
      const bytes = await __clipToBgCoverPngBytes(c, baseW, baseH);
      const fname = `bg_${String(i).padStart(3,"0")}.png`;
      try{ await ffmpeg.deleteFile(fname); }catch(_e){}
      await ffmpeg.writeFile(fname, bytes);
      args.push("-loop","1","-i", fname);
      inputs.push({ kind:"bg", idx, start, dur, name: fname });
      idx++;
    }

    // Video clips (each clip as its own input; audio is ignored/replaced by A1)
    for (let i=0;i<vClips.length;i++){
      const c = vClips[i];
      const m = media.find(mm => mm.id === c.mediaId);
      if (!m || m.kind!=="video") continue;
      const start = Math.max(0, Number(c.start||0));
      const dur = Math.max(0.001, Number(c.dur||0));
      const inSec = Math.max(0, Number(c.in||0));
      // Fetch source
      const blob = await fetch(m.url).then(r=>r.blob());
      const ext = __extFromBlobType(blob.type) || "mp4";
      const fname = `v_${String(i).padStart(3,"0")}.${ext}`;
      try{ await ffmpeg.deleteFile(fname); }catch(_e){}
      await __writeBlobToFs(fname, blob);
      args.push("-i", fname);
      inputs.push({ kind:"video", idx, start, dur, in: inSec, name: fname });
      idx++;
    }

    // Foreground overlays (all enabled GFX except BG image clips)
    const fgGfx = gfxClips.filter(c => !bgGfx.includes(c));
    for (let i=0;i<fgGfx.length;i++){
      const c = fgGfx[i];
      const start = Math.max(0, Number(c.start||0));
      const dur = Math.max(0.001, Number(c.dur||0));
      const bytes = await __clipToOverlayPngBytes(c, baseW, baseH);
      const fname = `ov_${String(i).padStart(3,"0")}.png`;
      try{ await ffmpeg.deleteFile(fname); }catch(_e){}
      await ffmpeg.writeFile(fname, bytes);
      args.push("-loop","1","-i", fname);
      inputs.push({ kind:"ov", idx, start, dur, name: fname });
      idx++;
    }

    // Audio clips (A1). Policy: A1 replaces video audio.
    const audioInputs = [];
    for (let i=0;i<aClips.length;i++){
      const c = aClips[i];
      const m = media.find(mm => mm.id === c.mediaId);
      if (!m || m.kind!=="audio") continue;
      const start = Math.max(0, Number(c.start||0));
      const dur = Math.max(0.001, Number(c.dur||0));
      const blob = await fetch(m.url).then(r=>r.blob());
      const ext = __extFromBlobType(blob.type) || "mp3";
      const fname = `a_${String(i).padStart(3,"0")}.${ext}`;
      try{ await ffmpeg.deleteFile(fname); }catch(_e){}
      await __writeBlobToFs(fname, blob);
      args.push("-i", fname);
      audioInputs.push({ idx, start, dur, name: fname });
      idx++;
    }

    // Build filter graph
    const W = baseW, H = baseH;
    const ar = (W/H);
    const fc = [];
    fc.push("[0:v]format=rgba[v0]");
    let vPrev = "v0";

    const fmt6 = (x) => (Number(x||0)).toFixed(6);

    // BG overlays first (behind video)
    for (let i=0;i<inputs.length;i++){
      const it = inputs[i];
      if (it.kind !== "bg") continue;
      const lbl = `bg${i}`;
      const out = `v_bg${i}`;
      fc.push(`[${it.idx}:v]format=rgba,trim=duration=${fmt6(it.dur)},setpts=PTS-STARTPTS+${fmt6(it.start)}/TB[${lbl}]`);
      fc.push(`[${vPrev}][${lbl}]overlay=0:0:eof_action=pass[${out}]`);
      vPrev = out;
    }

    // Video clips on top of bg
    let vidCount = 0;
    for (let i=0;i<inputs.length;i++){
      const it = inputs[i];
      if (it.kind !== "video") continue;
      const lbl = `vv${vidCount}`;
      const out = `v_v${vidCount}`;
      const inSec = Math.max(0, Number(it.in||0));
      fc.push(
        `[${it.idx}:v]trim=start=${fmt6(inSec)}:duration=${fmt6(it.dur)},`+
        `setpts=PTS-STARTPTS+${fmt6(it.start)}/TB,`+
        `scale=w='if(gt(a,${ar}),${W},-2)':h='if(gt(a,${ar}),-2,${H})':flags=bicubic,format=rgba[${lbl}]`
      );
      fc.push(`[${vPrev}][${lbl}]overlay=(main_w-overlay_w)/2:(main_h-overlay_h)/2:eof_action=pass[${out}]`);
      vPrev = out;
      vidCount++;
    }

    // Foreground overlays last
    let ovCount = 0;
    for (let i=0;i<inputs.length;i++){
      const it = inputs[i];
      if (it.kind !== "ov") continue;
      const lbl = `ov${ovCount}`;
      const out = `v_ov${ovCount}`;
      fc.push(`[${it.idx}:v]format=rgba,trim=duration=${fmt6(it.dur)},setpts=PTS-STARTPTS+${fmt6(it.start)}/TB[${lbl}]`);
      fc.push(`[${vPrev}][${lbl}]overlay=0:0:eof_action=pass[${out}]`);
      vPrev = out;
      ovCount++;
    }

    fc.push(`[${vPrev}]trim=duration=${fmt6(exportDur)}[vout]`);

    // Audio graph (mix multiple A1 clips)
    let hasAudio = audioInputs.length > 0;
    if (hasAudio){
      const alabs = [];
      for (let i=0;i<audioInputs.length;i++){
        const a = audioInputs[i];
        const ms = Math.max(0, Math.round(a.start * 1000));
        const lab = `a${i}`;
        // trim to clip.dur, delay to start time, then keep within exportDur
        fc.push(`[${a.idx}:a]atrim=0:${fmt6(a.dur)},asetpts=PTS-STARTPTS,adelay=${ms}|${ms}[${lab}]`);
        alabs.push(lab);
      }
      if (alabs.length === 1){
        fc.push(`[${alabs[0]}]atrim=0:${fmt6(exportDur)}[aout]`);
      }else{
        fc.push(`[${alabs.map(x=>`[${x}]`).join("")}amix=inputs=${alabs.length}:duration=longest,atrim=0:${fmt6(exportDur)}[aout]`);
      }
    }

    const filterComplex = fc.join(";");

    // Encode attempts (same philosophy as transcodeToMp4)
    const argsCommon = [...args,
      "-filter_complex", filterComplex,
      "-map", "[vout]"
    ];

    const encodeAttempts = [];
    if (hasAudio){
      encodeAttempts.push(
        [...argsCommon, "-map","[aout]", "-c:v","libx264","-preset","veryfast","-crf","28","-pix_fmt","yuv420p",
          "-c:a","aac","-b:a","160k","-movflags","+faststart", outputName]
      );
      encodeAttempts.push(
        [...argsCommon, "-map","[aout]", "-c:v","libx264","-preset","veryfast","-crf","28","-pix_fmt","yuv420p",
          "-c:a","libmp3lame","-b:a","160k","-movflags","+faststart", outputName]
      );
    }else{
      encodeAttempts.push(
        [...argsCommon, "-an", "-c:v","libx264","-preset","veryfast","-crf","28","-pix_fmt","yuv420p",
          "-movflags","+faststart", outputName]
      );
    }

    let lastErr = null;
    for (const enc of encodeAttempts){
      try{
        await ffmpeg.exec(enc);
        lastErr = null;
        break;
      }catch(e){
        lastErr = e;
      }
    }
    if (lastErr) throw lastErr;

    const out = await ffmpeg.readFile(outputName);
    return new Blob([out.buffer], { type:"video/mp4" });
  }



exportWebmBtn.addEventListener("click", async () => {
    try{
      setStatus("Exporting MP4 from timeline‚Ä¶ (first run can take a bit)");
      const outBlob = await exportTimelineToMp4((msg) => {
        try{
          if (!msg) return;
          setStatus(String(msg).length > 110 ? String(msg).slice(-110) : String(msg));
        }catch(_e){}
      });
      downloadBlob(outBlob, (projectName.textContent||"warcut") + ".mp4");
      setStatus("Exported MP4 ‚úì");
    }catch(err){
      console.error(err);
      const hint = "Tip: run on http(s) (not file://). If media assets were restored from autosave, re-import them.";
      setStatus("Export failed: " + (err?.message || err) + " ‚Äî " + hint);
    }
  });


  // Modal helper
  function openModal(mod){
    mod.classList.add("show");
    mod.setAttribute("aria-hidden","false");
  }
  function closeModal(mod){
    mod.classList.remove("show");
    mod.setAttribute("aria-hidden","true");
  }
  // help modal click-outside handled by #helpModalBackdrop
exportModal.addEventListener("click", (e) => { if (e.target === exportModal) closeModal(exportModal); });

  // Resize timeline height (drag handle)
  (() => {
    let dragging = false;
    let startY = 0;
    let startH = 0;
    timelineResize.addEventListener("mousedown", (e) => {
      dragging = true;
      startY = e.clientY;
      startH = timelineEl.getBoundingClientRect().height;
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", onUp, { once:true });
    });
    function onMove(e){
      if (!dragging) return;
      const dy = e.clientY - startY;
      const h = Math.max(160, Math.min(420, startH - dy));
      timelineEl.style.height = h + "px";
    }
    function onUp(){
      dragging = false;
      window.removeEventListener("mousemove", onMove);
    }
  })();

  // Keyboard shortcuts
  window.addEventListener("keydown", (e) => {
    if (e.target && (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA")) return;
    const mod = e.ctrlKey || e.metaKey;
    if (mod && !e.shiftKey && (e.key === "z" || e.key === "Z")){
      e.preventDefault();
      undo();
      return;
    }
    if (mod && ((e.key === "y" || e.key === "Y") || (e.shiftKey && (e.key === "z" || e.key === "Z")))){
      e.preventDefault();
      redo();
      return;
    }

    if (e.code === "Space"){
      e.preventDefault();
      togglePlay();
    }
    if (e.code === "ArrowLeft"){
      e.preventDefault();
      step(-1);
    }
    if (e.code === "ArrowRight"){
      e.preventDefault();
      step(1);
    }
    if ((e.key === "Delete" || e.key === "Backspace") && selectedClipId){
      e.preventDefault();
      deleteBtn.click();
    }
  });

  // Initial build
  updateBin();
  updateCounts();
  buildRuler();
  renderTimeline();
  renderOverlays();
  seekPreviewTo(0);
  __updateUndoRedoButtons();
  refreshCodecUI(media.find(x=>x.id===selectedMediaId) || null).catch(()=>{});

  // keep playhead visible when it moves
  function autoScrollPlayhead(){
    const x = secToX(playhead);
    const viewL = laneScroll.scrollLeft;
    const viewR = viewL + laneScroll.clientWidth - 20;
    if (x < viewL + 40) laneScroll.scrollLeft = Math.max(0, x - 60);
    else if (x > viewR - 40) laneScroll.scrollLeft = x - (laneScroll.clientWidth - 80);
  }

  // small interval for scroll assist (when playing)
  setInterval(() => {
    if (!isPlaying) return;
    autoScrollPlayhead();
  }, 120);

  // Pause on visibility loss
  document.addEventListener("visibilitychange", () => {
    if (document.hidden && isPlaying) pause();
  });

  // Audio master routing:
// - "Clip audio only": use the <video> element's audio (per-clip mute still applies)
// - "WebAudio": mute the <video> element and play imported A1 audio clips via WebAudio
  const audioMasterSel = $("#audioMaster");
  function applyAudioMaster(){
    const mode = audioMasterSel.value;
    if (mode === "clip"){
      stopAudio();
      const active = getActiveVideoClip(playhead);
      previewVideo.muted = masterMuted || (active ? !!active.clipAudioMuted : false);
      setStatus("Audio master: clip audio only.");
      updateMasterMuteBtn();
    } else {
      previewVideo.muted = true;
      if (isPlaying) startAudioAt(playhead);
      setStatus("Audio master: WebAudio.");
      updateMasterMuteBtn();
    }
  }
  audioMasterSel.addEventListener("change", applyAudioMaster);
  applyAudioMaster();

  // ----------------------------------------------------------
  // Phase B (Stages 4‚Äì5) Debug Hook Stabilizer
  // Some builds may reassign window.__warcutDebug late in the module.
  // This tiny merger re-attaches PhaseB helpers to __warcutDebug repeatedly
  // for a short window to avoid "not a function" surprises.
  // ----------------------------------------------------------
  try{
    window.__warcutPhaseB = window.__warcutPhaseB || {};
    const __B_mergePhaseBDebug = () => {
      const pb  = window.__warcutPhaseB;
      const dbg = window.__warcutDebug;
      if (!pb || !dbg || typeof dbg !== "object") return false;

      // Stack 1
      if (typeof pb.getOverlayTimeClass === "function") dbg.getOverlayTimeClass = pb.getOverlayTimeClass;
      if (typeof pb.getActiveOverlaysAtTime === "function") dbg.getActiveOverlaysAtTime = pb.getActiveOverlaysAtTime;

      // Stack 2
      if (typeof pb.buildFrameSignature === "function") dbg.buildFrameSignature = pb.buildFrameSignature;
      if (typeof pb.buildDirtyFrameRanges === "function") dbg.buildDirtyFrameRanges = pb.buildDirtyFrameRanges;
      if (pb.dirty) dbg.dirty = pb.dirty;

      // Stack 3
      if (typeof pb.buildOverlayRenderSchedule === "function") dbg.buildOverlayRenderSchedule = pb.buildOverlayRenderSchedule;
      if (typeof pb.buildOverlayRenderScheduleV2 === "function") dbg.buildOverlayRenderScheduleV2 = pb.buildOverlayRenderScheduleV2;

      // Stage 5 / Stack 4
      if (typeof pb.rasterizeOverlaysToPngFramesV2 === "function") dbg.rasterizeOverlaysToPngFramesV2 = pb.rasterizeOverlaysToPngFramesV2;
      if (typeof pb.rasterizeOverlaysToPngFramesLegacy === "function") dbg.rasterizeOverlaysToPngFramesLegacy = pb.rasterizeOverlaysToPngFramesLegacy;
      if (typeof dbg.rasterizeOverlaysToPngFrames !== "function" && typeof pb.rasterizeOverlaysToPngFramesV2 === "function") {
        dbg.rasterizeOverlaysToPngFrames = pb.rasterizeOverlaysToPngFramesV2;
      }
      return true;
    };

    // Allow manual repair from DevTools if needed.
    if (typeof window.__warcutPhaseB.installDebugHooks !== "function"){
      window.__warcutPhaseB.installDebugHooks = __B_mergePhaseBDebug;
    }

    // Try now + a few times shortly after (covers late reassignment).
    __B_mergePhaseBDebug();
    let __B_tries = 0;
    const __B_timer = setInterval(() => {
      __B_tries++;
      const ok = __B_mergePhaseBDebug();
      if ((ok && __B_tries >= 6) || __B_tries >= 60) clearInterval(__B_timer);
    }, 100);

    // One more merge on window load just in case.
    window.addEventListener("load", () => __B_mergePhaseBDebug(), { once: true });
  }catch(_e){ /* ignore */ }

})();
</script>
</body>
</html>